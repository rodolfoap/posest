/*////////////////////////////////////////////////////////////////////////////////
// 
//  Routines related to motion and structure estimation
//
//  Copyright (C) 2002-13  Manolis Lourakis (lourakis **at** ics.forth.gr)
//  Institute of Computer Science, Foundation for Research & Technology - Hellas
//  Heraklion, Crete, Greece.
//
//////////////////////////////////////////////////////////////////////////////// */

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <math.h>
#include <float.h>

#include "compiler.h"
//#include "svd3.h"

#include "sam.h"

#define _SAM_ZEROANGLE  1E-14

/* LAPACK eigenvalues/eigenvectors (packed & unpacked storage) */
extern int F77_FUNC(dspev)(char *jobz, char *uplo, int *n, double *ap, double *w, double *z, int *ldz, double *work, int *info);
extern int F77_FUNC(dsyev)(char *jobz, char *uplo, int *n, double *a, int *lda, double *w, double *work, int *lwork, int *info);

/* SVD */
extern int F77_FUNC(dgesvd)(
      char *jobu, char *jobvt, int *m, int *n, double *a, int *lda, double *s,
      double *u, int *ldu, double *vt, int *ldvt, double *work, int *lwork, int *info);

/*
 * compute the inverse of a 3x3 matrix A into A1
 * using the determinant
 *
 * The function returns 1 in case of error (e.g. A is singular),
 * 0 if successfull
 */
int sam_inv3x3(double *a, double *a1)
{
double t4, t6, t8, t10, t12, t14, t17;

  /* Code generated by maple's codegen package and minimal editing */
  t4 = a[0]*a[4];
  t6 = a[0]*a[5];
  t8 = a[1]*a[3];
  t10 = a[2]*a[3];
  t12 = a[1]*a[6];
  t14 = a[2]*a[6];
  t17 = t4*a[8]-t6*a[7]-t8*a[8]+t10*a[7]+t12*a[5]-t14*a[4];
  if(-DBL_MIN<=t17 && t17<=DBL_MIN){
    fprintf(stderr, "Zero determinant (%g) in sam_inv3x3()\n", t17);
    return 1;
  }

  t17 = 1/t17;
  a1[0] = (a[4]*a[8]-a[5]*a[7])*t17;
  a1[1] = -(a[1]*a[8]-a[2]*a[7])*t17;
  a1[2] = (a[1]*a[5]-a[2]*a[4])*t17;
  a1[3] = -(a[3]*a[8]-a[5]*a[6])*t17;
  a1[4] = (a[0]*a[8]-t14)*t17;
  a1[5] = -(t6-t10)*t17;
  a1[6] = (a[3]*a[7]-a[4]*a[6])*t17;
  a1[7] = -(a[0]*a[7]-t12)*t17;
  a1[8] = (t4-t8)*t17;

  return 0;
}

/* determinant of 3x3 matrix */
double sam_det3x3(double a[9])
{
double t4, t6, t8, t10, t12, t14;

  /* Code generated by maple's codegen package and minimal editing */
  t4 = a[0]*a[4];
  t6 = a[0]*a[5];
  t8 = a[1]*a[3];
  t10 = a[2]*a[3];
  t12 = a[1]*a[6];
  t14 = a[2]*a[6];
  return t4*a[8]-t6*a[7]-t8*a[8]+t10*a[7]+t12*a[5]-t14*a[4];
}

/* compute the rotation matrix corresponding to a rotation vector (Rodrigues); see Horn's paper */
void sam_vec2rotmat(double r[3], double R[9])
{
double phi, s, q[4];

  /* convert r to quaternion */
  phi=r[0]*r[0] + r[1]*r[1] + r[2]*r[2];
  if(phi<=_SAM_ZEROANGLE){ // zero, R=I
    R[0]=R[4]=R[8]=1.0;
    R[1]=R[2]=R[3]=R[5]=R[6]=R[7]=0.0;
    return;
  }
  phi=sqrt(phi); // angle

  s=sin(0.5*phi)/phi;
  q[0]=cos(0.5*phi);
  q[1]=r[0]*s;
  q[2]=r[1]*s;
  q[3]=r[2]*s;

  R[0]=q[0]*q[0]+q[1]*q[1]-q[2]*q[2]-q[3]*q[3];
	R[1]=2*(q[1]*q[2]-q[0]*q[3]);
	R[2]=2*(q[1]*q[3]+q[0]*q[2]);

	R[3]=2*(q[1]*q[2]+q[0]*q[3]);
	R[4]=q[0]*q[0]+q[2]*q[2]-q[1]*q[1]-q[3]*q[3];
	R[5]=2*(q[2]*q[3]-q[0]*q[1]);

	R[6]=2*(q[1]*q[3]-q[0]*q[2]);
	R[7]=2*(q[2]*q[3]+q[0]*q[1]);
	R[8]=q[0]*q[0]+q[3]*q[3]-q[1]*q[1]-q[2]*q[2];
}

/* compute the rotation matrix corresponding to an axisangle representation; see Horn's paper */
void sam_axangle2rotmat(double n[3], double phi, double R[9])
{
double mag, s;
double q[4]; // quaternion for n, phi rotation

  /* ensure axis is of unit length */
  mag=1.0/sqrt(n[0]*n[0] + n[1]*n[1] + n[2]*n[2]);

  phi*=0.5;
  s=sin(phi)*mag;
  q[0]=cos(phi);
  q[1]=n[0]*s;
  q[2]=n[1]*s;
  q[3]=n[2]*s;

  R[0]=q[0]*q[0]+q[1]*q[1]-q[2]*q[2]-q[3]*q[3];
  R[1]=2*(q[1]*q[2]-q[0]*q[3]);
  R[2]=2*(q[1]*q[3]+q[0]*q[2]);

  R[3]=2*(q[1]*q[2]+q[0]*q[3]);
  R[4]=q[0]*q[0]+q[2]*q[2]-q[1]*q[1]-q[3]*q[3];
  R[5]=2*(q[2]*q[3]-q[0]*q[1]);

  R[6]=2*(q[1]*q[3]-q[0]*q[2]);
  R[7]=2*(q[2]*q[3]+q[0]*q[1]);
  R[8]=q[0]*q[0]+q[3]*q[3]-q[1]*q[1]-q[2]*q[2];
}

/* compute the rotation vector (Rodrigues) corresponding to a rotation matrix; see A8 in Horn's paper */
#define _clamp(a, b, x) ( ((x)<=(a))? (a) : (((x)<=(b))? (x) : (b)) )
void sam_rotmat2vec(double R[9], double r[3])
{
register int i;
int maxpos=-1; /* -Wall */
double q[4]; /* quaternion */
double tmp[4], mag, s, s1;

	/* find the maximum of the 4 quantities */
	tmp[0]=1.0 + R[0] + R[4] + R[8];
	tmp[1]=1.0 + R[0] - R[4] - R[8];
	tmp[2]=1.0 - R[0] + R[4] - R[8];
	tmp[3]=1.0 - R[0] - R[4] + R[8];

	for(i=0, mag=-1.0; i<4; i++)
		if(tmp[i]>mag){
			mag=tmp[i];
			maxpos=i;
		}

	switch(maxpos){
	case 0:
		q[0]=sqrt(tmp[0])*0.5;
		q[1]=(R[7] - R[5])/(4.0*q[0]);
		q[2]=(R[2] - R[6])/(4.0*q[0]);
		q[3]=(R[3] - R[1])/(4.0*q[0]);
		break;
	case 1:
		q[1]=sqrt(tmp[1])*0.5;
		q[0]=(R[7] - R[5])/(4.0*q[1]);
		q[2]=(R[3] + R[1])/(4.0*q[1]);
		q[3]=(R[2] + R[6])/(4.0*q[1]);
		break;
	case 2:
		q[2]=sqrt(tmp[2])*0.5;
		q[0]=(R[2] - R[6])/(4.0*q[2]);
		q[1]=(R[3] + R[1])/(4.0*q[2]);
		q[3]=(R[7] + R[5])/(4.0*q[2]);
		break;
	case 3:
		q[3]=sqrt(tmp[3])*0.5;
		q[0]=(R[3] - R[1])/(4.0*q[3]);
		q[1]=(R[2] + R[6])/(4.0*q[3]);
		q[2]=(R[7] + R[5])/(4.0*q[3]);
		break;
	default: /* should not happen */
		fprintf(stderr, "Internal error in sam_rotmat2vec()\nR:\n");
		fprintf(stderr, "%g %g %g\n", R[0], R[1], R[2]);
		fprintf(stderr, "%g %g %g\n", R[3], R[4], R[5]);
		fprintf(stderr, "%g %g %g\n", R[6], R[7], R[8]);
		exit(1);
	}

	/* enforce unit length */
	mag=q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + q[3]*q[3];
	if(mag!=1.0){
	  mag=1.0/sqrt(mag);
	  q[0]*=mag; q[1]*=mag; q[2]*=mag; q[3]*=mag;
  }

  /* convert quaternion q to rotation vector */
  s=acos(_clamp(-1.0, 1.0, q[0])); // retrieve angle/2
  s1=sin(s);
  if(fabs(s1)>_SAM_ZEROANGLE){
    s=2.0*s/s1;
    r[0]=q[1]*s; r[1]=q[2]*s; r[2]=q[3]*s;
  }else{ // angle close to zero, axis direction unimportant
    r[0]=2.0*s; r[1]=0.0; r[2]=0.0;
  }
}
#undef _clamp

/* compute the rotation matrix corresponding to a quaternion; see Horn's paper */
void sam_quat2rotmat(double q[4], double R[9])
{
double mag;

	/* ensure unit length */
	mag=q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + q[3]*q[3];
	if(mag!=1.0){
		mag=1.0/sqrt(mag);
		q[0]*=mag; q[1]*=mag; q[2]*=mag; q[3]*=mag;
	}

  R[0]=q[0]*q[0]+q[1]*q[1]-q[2]*q[2]-q[3]*q[3];
	R[1]=2*(q[1]*q[2]-q[0]*q[3]);
	R[2]=2*(q[1]*q[3]+q[0]*q[2]);

	R[3]=2*(q[1]*q[2]+q[0]*q[3]);
	R[4]=q[0]*q[0]+q[2]*q[2]-q[1]*q[1]-q[3]*q[3];
	R[5]=2*(q[2]*q[3]-q[0]*q[1]);

	R[6]=2*(q[1]*q[3]-q[0]*q[2]);
	R[7]=2*(q[2]*q[3]+q[0]*q[1]);
	R[8]=q[0]*q[0]+q[3]*q[3]-q[1]*q[1]-q[2]*q[2];
}

#if 0
// as above with faster computation; see quattomat() from listing 15.3 in Watt and Watt:
// "Advanced Animation and Rendering Techniques: Theory and Practice";
// excerpt at http://www.cs.cmu.edu/afs/cs/academic/class/15462-s12/www/lec_slides/3DRotationNotes.pdf
// NOTE: the quaternion is *not* normalized upon return!
void sam_quat2rotmat(double q[4], double R[9])
{
const double w=q[0], x=q[1], y=q[2], z=q[3];
register double s=2.0/(w*w + x*x + y*y + z*z);

  double xs=x*s, ys=y*s, zs=z*s;
  double wx=w*xs, wy=w*ys, wz=w*zs;
  double xx=x*xs, xy=x*ys, xz=x*zs;
  double yy=y*ys, yz=y*zs, zz=z*zs;

  R[0]=1.0 - yy - zz;
  R[1]=xy - wz;
  R[2]=xz + wy;

  R[3]=xy + wz;
  R[4]=1.0 - xx - zz;
  R[5]=yz - wx;

  R[6]=xz - wy;
  R[7]=yz + wx;
  R[8]=1.0 - xx - yy;
}
#endif

/* compute the quaternion corresponding to a rotation matrix; see A8 in Horn's paper */
void sam_rotmat2quat(double R[9], double q[4])
{
register int i;
int maxpos=-1; /* -Wall */
double tmp[4], mag;

	/* find the maximum of the 4 quantities */
	tmp[0]=1.0 + R[0] + R[4] + R[8];
	tmp[1]=1.0 + R[0] - R[4] - R[8];
	tmp[2]=1.0 - R[0] + R[4] - R[8];
	tmp[3]=1.0 - R[0] - R[4] + R[8];

	for(i=0, mag=-1.0; i<4; i++)
		if(tmp[i]>mag){
			mag=tmp[i];
			maxpos=i;
		}

	switch(maxpos){
	case 0:
		q[0]=sqrt(tmp[0])*0.5;
		q[1]=(R[7] - R[5])/(4.0*q[0]);
		q[2]=(R[2] - R[6])/(4.0*q[0]);
		q[3]=(R[3] - R[1])/(4.0*q[0]);
		break;
	case 1:
		q[1]=sqrt(tmp[1])*0.5;
		q[0]=(R[7] - R[5])/(4.0*q[1]);
		q[2]=(R[3] + R[1])/(4.0*q[1]);
		q[3]=(R[2] + R[6])/(4.0*q[1]);
		break;
	case 2:
		q[2]=sqrt(tmp[2])*0.5;
		q[0]=(R[2] - R[6])/(4.0*q[2]);
		q[1]=(R[3] + R[1])/(4.0*q[2]);
		q[3]=(R[7] + R[5])/(4.0*q[2]);
		break;
	case 3:
		q[3]=sqrt(tmp[3])*0.5;
		q[0]=(R[3] - R[1])/(4.0*q[3]);
		q[1]=(R[2] + R[6])/(4.0*q[3]);
		q[2]=(R[7] + R[5])/(4.0*q[3]);
		break;
	default: /* should not happen */
		fprintf(stderr, "Internal error in sam_rotmat2quat()\nR:\n");
		fprintf(stderr, "%g %g %g\n", R[0], R[1], R[2]);
		fprintf(stderr, "%g %g %g\n", R[3], R[4], R[5]);
		fprintf(stderr, "%g %g %g\n", R[6], R[7], R[8]);
		exit(1);
	}

	/* enforce unit length */
	mag=q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + q[3]*q[3];

	if(mag==1.0) return;

	mag=1.0/sqrt(mag);
	q[0]*=mag; q[1]*=mag; q[2]*=mag; q[3]*=mag;
}

/* convert a rotation vector to quaternion */
void sam_vec2quat(double r[3], double q[4])
{
double th, s;

  th=sqrt(r[0]*r[0] + r[1]*r[1] + r[2]*r[2]);
  if(th>_SAM_ZEROANGLE){
    s=sin(0.5*th)/th;
    q[0]=cos(0.5*th);
    q[1]=r[0]*s;
    q[2]=r[1]*s;
    q[3]=r[2]*s;
  }
  else{
    q[0]=1.0;
    q[1]=q[2]=q[3]=0.0;
  }
}

/* convert quaternion to rotation vector */
#define _clamp(a, b, x) ( ((x)<=(a))? (a) : (((x)<=(b))? (x) : (b)) )
void sam_quat2vec(double q[4], double r[3])
{
double mag, th, s;

  mag=q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + q[3]*q[3];
  if(mag<0.99999 || mag>1.00001){ // normalize
    mag=1.0/sqrt(mag);
    q[0]*=mag;
    q[1]*=mag;
    q[2]*=mag;
    q[3]*=mag;
  }

  th=acos(_clamp(-1.0, 1.0, q[0]));
  s=sin(th);
  if(fabs(s)>_SAM_ZEROANGLE){
    th=2.0*th;
    s=th/s;
    r[0]=q[1]*s;
    r[1]=q[2]*s;
    r[2]=q[3]*s;
  }
  else{
    r[0]=r[1]=r[2]=0.0; // s close to zero
  }
}
#undef _clamp

/* normalize the rotation vector r so that it corresponds to a rotation angle in [-pi, pi]
 * see http://stackoverflow.com/questions/4633177/c-how-to-wrap-a-float-to-the-interval-pi-pi
 */
void sam_rvecnorm(double r[3])
{
double th, s;
const double low=-M_PI, high=M_PI;
double range;

  th=sqrt(r[0]*r[0] + r[1]*r[1] + r[2]*r[2]);
  if(th==0.0) return; // r=[0 0 0]

  range=high-low;
  if(range==0.0) s=high; // avoid dividing by 0
  else s=th - (range*floor((th-low)/range));

  s=s/th;
  r[0]*=s;
  r[1]*=s;
  r[2]*=s;
}

/* compute r, t as R2*R1, R2*t1+t2 */
void sam_composeMotions(double R1[9], double t1[3], double R2[9], double t2[3], double R[9], double t[3])
{
register int i;

  /* R=R2*R1, t=R2*t1+t2 */
  for(i=0; i<3; ++i){
    R[i*3  ]=R2[i*3]*R1[0] + R2[i*3+1]*R1[1*3  ] + R2[i*3+2]*R1[2*3  ];
    R[i*3+1]=R2[i*3]*R1[1] + R2[i*3+1]*R1[1*3+1] + R2[i*3+2]*R1[2*3+1];
    R[i*3+2]=R2[i*3]*R1[2] + R2[i*3+1]*R1[1*3+2] + R2[i*3+2]*R1[2*3+2];

    t[i]=R2[i*3]*t1[0] + R2[i*3+1]*t1[1] + R2[i*3+2]*t1[2] + t2[i];
  }
}

/* As sam_composeMotions() with rotations represented with vectors: compute r, t as R(r)=R(r2)*R(r1), R(r2)*t1+t2 */
void sam_composeMotionsr(double r1[3], double t1[3], double r2[3], double t2[3], double r[3], double t[3])
{
double q1[4], q2[4], q[4];

  sam_vec2quat(r1, q1);
  sam_vec2quat(r2, q2);
  sam_composeMotionsq(q1, t1, q2, t2, q, t);
  sam_quat2vec(q, r);
}

/*
 * Compute q as the composition (product) of the two rotations represented by
 * the quaternions q2 and q1. The combined rotation (q1 followed by q2) equals
 * R=R2*R1 in equivalent 3x3 matrices. In addition, rotates t1 by q2 and ads t2,
 * i.e. t=R2*t1 + t2
 *
 * Similar to sam_composeMotions() for rotations represented with quaternions
 *
 * (symbolically r=q2*q1, t=q2*t1 + t2)
 * 
 */
void sam_composeMotionsq(double q1[4], double t1[3], double q2[4], double t2[3], double q[4], double t[3])
{
double mag;
double ta, tb, tc, td;

  /* ensure q1, q2 are of unit norm */
  mag=q1[0]*q1[0] + q1[1]*q1[1] + q1[2]*q1[2] + q1[3]*q1[3];
  if(mag!=1.0){
    mag=1.0/sqrt(mag);
    q1[0]*=mag; q1[1]*=mag; q1[2]*=mag; q1[3]*=mag;
  }

  mag=q2[0]*q2[0] + q2[1]*q2[1] + q2[2]*q2[2] + q2[3]*q2[3];
  if(mag!=1.0){
    mag=1.0/sqrt(mag);
    q2[0]*=mag; q2[1]*=mag; q2[2]*=mag; q2[3]*=mag;
  }

  /* compute quaternion q=[s, r] as the product of q2=[s2, v2] and q1=[s1, v1] */
  q[0]=q2[0]*q1[0] - (q2[1]*q1[1]+q2[2]*q1[2]+q2[3]*q1[3]); // s
  /* r = v2 x v1 */
  q[1]=q2[2]*q1[3] - q2[3]*q1[2];
  q[2]=q2[3]*q1[1] - q2[1]*q1[3];
  q[3]=q2[1]*q1[2] - q2[2]*q1[1];
  /* r = r + s2*v1 */
  q[1]+=q2[0]*q1[1]; q[2]+=q2[0]*q1[2]; q[3]+=q2[0]*q1[3];
  /* r = r + s1*v2 */
  q[1]+=q1[0]*q2[1]; q[2]+=q1[0]*q2[2]; q[3]+=q1[0]*q2[3];

  /* q2*t1 is computed as qq*(0, t1)*qq', where qq=[s2, v2].
   * qq is of unit magnitude so qqinv==qqconj.
   * Following code fragment generated using maple
   */

  ta=-q2[1]*t1[0]-q2[2]*t1[1]-q2[3]*t1[2];
  tb= q2[0]*t1[0]+q2[2]*t1[2]-q2[3]*t1[1];
  tc= q2[0]*t1[1]+q2[3]*t1[0]-q2[1]*t1[2];
  td= q2[0]*t1[2]+q2[1]*t1[1]-q2[2]*t1[0];

  t[0]=-ta*q2[1]+q2[0]*tb-tc*q2[3]+td*q2[2];
  t[1]=-ta*q2[2]+q2[0]*tc-q2[1]*td+tb*q2[3];
  t[2]=-ta*q2[3]+q2[0]*td-tb*q2[2]+q2[1]*tc;

  t[0]+=t2[0];
  t[1]+=t2[1];
  t[2]+=t2[2];
}

/* compute the relative motion between R1,t1 & R2,t2, i.e. r, t bringing R1,t1 to R2,t2 as
 * R2*R1^T, t2-R*t1 (equivalently R2=R*R1, t2=R*t1+t)
 */
void sam_relMotion(double R1[9], double t1[3], double R2[9], double t2[3], double R[9], double t[3])
{
register int i;

  /* R=R2*R1', t=t2-R*t1 */
  for(i=0; i<3; ++i){
    R[i*3  ]=R2[i*3]*R1[0  ] + R2[i*3+1]*R1[1    ] + R2[i*3+2]*R1[2    ];
    R[i*3+1]=R2[i*3]*R1[1*3] + R2[i*3+1]*R1[1*3+1] + R2[i*3+2]*R1[1*3+2];
    R[i*3+2]=R2[i*3]*R1[2*3] + R2[i*3+1]*R1[2*3+1] + R2[i*3+2]*R1[2*3+2];

    t[i]=t2[i] - (R[i*3]*t1[0] + R[i*3+1]*t1[1] + R[i*3+2]*t1[2]);
  }
}

/* compute the composition of two rigid motions whose rotations are represented by 3-vectors.
 * Similar to sam_composeMotions()/sam_composeMotions() above for rotations represented with
 * Rodrigues vectors.
 *
 * (symbolically r=r2*r1, t=r2*t1 + t2)
 * 
 */
void sam_composeMotionsvec(double r1[3], double t1[3], double r2[3], double t2[3], double r[3], double t[3])
{
double q1[4], q2[4], q[4];

  sam_vec2quat(r1, q1);
  sam_vec2quat(r2, q2);

  sam_composeMotionsq(q1, t1, q2, t2, q, t);

  sam_quat2vec(q, r);
}

/*
 * Given a motion R, t compute the inverse motion R', -R'*t
 */
void sam_inverseMotion(double R[9], double t[3], double Ri[9], double ti[3])
{
  Ri[0]=R[0]; Ri[1]=R[3]; Ri[2]=R[6];
  Ri[3]=R[1]; Ri[4]=R[4]; Ri[5]=R[7];
  Ri[6]=R[2]; Ri[7]=R[5]; Ri[8]=R[8];

  ti[0]=-(Ri[0]*t[0] + Ri[1]*t[1] + Ri[2]*t[2]);
  ti[1]=-(Ri[3]*t[0] + Ri[4]*t[1] + Ri[5]*t[2]);
  ti[2]=-(Ri[6]*t[0] + Ri[7]*t[1] + Ri[8]*t[2]);
}

/* as above but for rotation represented with a quaternion */
void sam_inverseMotionq(double qrt[7], double qrti[7])
{
double Ri[9];

  qrti[0]=-qrt[0];
  qrti[1]= qrt[1];
  qrti[2]= qrt[2];
  qrti[3]= qrt[3];
  sam_quat2rotmat(qrti, Ri); // R'

  /* -R'*t */
  qrti[4]=-(Ri[0]*qrt[4] + Ri[1]*qrt[5] + Ri[2]*qrt[6]);
  qrti[5]=-(Ri[3]*qrt[4] + Ri[4]*qrt[5] + Ri[5]*qrt[6]);
  qrti[6]=-(Ri[6]*qrt[4] + Ri[7]*qrt[5] + Ri[8]*qrt[6]);
}

/* as above but for rotation represented with a rotation vector */
void sam_inverseMotionr(double rt[6], double rti[6])
{
double qrt[7], qrti[7];

  sam_vec2quat(rt, qrt);
  qrt[4]=rt[3];
  qrt[5]=rt[4];
  qrt[6]=rt[5];

  sam_inverseMotionq(qrt, qrti);

  sam_quat2vec(qrti, rti);
  rti[3]=qrti[4];
  rti[4]=qrti[5];
  rti[5]=qrti[6];
}

/* Assuming that the camera pose transforms from rta to rtb, computes in xpts3D the
 * 3D points in pts3D transformed accordingly; xpts3D can coincide with pts3D.
 * One of rta, rtb (but not both!) can be NULL, in which case pose I, 0 is assumed.
 *
 * Let M be a 3D point with pose R1, t1 in the coordinate system of a camera.
 * If the point is transformed to have pose R2, t2, M becomes N and the following holds:
 * R1*M + t1 = R2*N + t2 ==> R1*M + t1 - t2 = R2*N ==> N = R2'*(R1*M + t1 - t2) =
 * R2'*R1*M + R2'*(t1-t2). Thus, M transforms with R2'*R1, R2'*(t1-t2).
 *
 * [ Note that this a "point" pose that corresponds to "camera" pose R1'*R2, R1'*(t2-t1),
 *   which is exactly the motion transforming R1, t1 to R2, t2, see poseXForm.m ]
 *
 * Since R1, t1 and R2, t2 are point poses, they relate to Ra,ta and Rb,tb corresponding
 * respectively to rta, rtb with R1=Ra', t1=-Ra'*ta and R2=Rb', t2=-Rb'*tb. Therefore, M
 * transforms with Rb*Ra', Rb*(-Ra'*ta + Rb'*tb)
 */ 
void sam_xformPoints(double (*pts3D)[3], int npts, double rta[6], double rtb[6], double (*xpts3D)[3])
{
register int i;
double Ra[9], Rb[9], R[9], t[3];
register double X, Y, Z;

  if(rta){
    sam_vec2rotmat(rta, Ra);
    if(rtb){
      sam_vec2rotmat(rtb, Rb);
      /* R=Rb*Ra' */
      for(i=0; i<3; ++i){
        R[i*3  ]=Rb[i*3]*Ra[0  ] + Rb[i*3+1]*Ra[1    ] + Rb[i*3+2]*Ra[2    ];
        R[i*3+1]=Rb[i*3]*Ra[1*3] + Rb[i*3+1]*Ra[1*3+1] + Rb[i*3+2]*Ra[1*3+2];
        R[i*3+2]=Rb[i*3]*Ra[2*3] + Rb[i*3+1]*Ra[2*3+1] + Rb[i*3+2]*Ra[2*3+2];
      }

      /** t=Rb*(-Ra'*ta + Rb'*tb) **/
      /* XYZ=-Ra'*ta */
      X=-(Ra[0]*rta[3] + Ra[3]*rta[4] + Ra[6]*rta[5]);
      Y=-(Ra[1]*rta[3] + Ra[4]*rta[4] + Ra[7]*rta[5]);
      Z=-(Ra[2]*rta[3] + Ra[5]*rta[4] + Ra[8]*rta[5]);

      /* XYZ+=Rb'*tb */
      X+=Rb[0]*rtb[3] + Rb[3]*rtb[4] + Rb[6]*rtb[5];
      Y+=Rb[1]*rtb[3] + Rb[4]*rtb[4] + Rb[7]*rtb[5];
      Z+=Rb[2]*rtb[3] + Rb[5]*rtb[4] + Rb[8]*rtb[5];
      /* t=Rb*XYZ */
      t[0]=Rb[0]*X + Rb[1]*Y + Rb[2]*Z;
      t[1]=Rb[3]*X + Rb[4]*Y + Rb[5]*Z;
      t[2]=Rb[6]*X + Rb[7]*Y + Rb[8]*Z;
    }
    else{ // [Rb tb]=[I | 0]
      /* R=Ra' */
      R[0]=Ra[0]; R[1]=Ra[3]; R[2]=Ra[6];
      R[3]=Ra[1]; R[4]=Ra[4]; R[5]=Ra[7];
      R[6]=Ra[2]; R[7]=Ra[5]; R[8]=Ra[8];

      /* t=-Ra'*ta */
      t[0]=-(Ra[0]*rta[3] + Ra[3]*rta[4] + Ra[6]*rta[5]);
      t[1]=-(Ra[1]*rta[3] + Ra[4]*rta[4] + Ra[7]*rta[5]);
      t[2]=-(Ra[2]*rta[3] + Ra[5]*rta[4] + Ra[8]*rta[5]);
    }
  }
  else{ // [Ra ta]=[I | 0]
    /* R=Rb */
    sam_vec2rotmat(rtb, R);

    /* t=tb */
    t[0]=rtb[3];
    t[1]=rtb[4];
    t[2]=rtb[5];
  }

  /* xpts3D_i = R*pts3D_i + t */
  for(i=0; i<npts; ++i){
    X=pts3D[i][0];
    Y=pts3D[i][1];
    Z=pts3D[i][2];

    xpts3D[i][0]=(R[0]*X + R[1]*Y) + (R[2]*Z + t[0]);
    xpts3D[i][1]=(R[3]*X + R[4]*Y) + (R[5]*Z + t[1]);
    xpts3D[i][2]=(R[6]*X + R[7]*Y) + (R[8]*Z + t[2]);
  }
}

/* compute the projection matrix corresponding to intrinsics in K and motion r, t: P=K*[R(r) t] */
void sam_PfromKrt(double K[9], double r[3], double t[3], double P[12])
{
register int i;
double R[9];

  sam_vec2rotmat(r, R);

  /* P=[K*R | K*t] */
  for(i=0; i<3; ++i){
    P[i*4  ]=K[i*3]*R[0] + K[i*3+1]*R[1*3  ] + K[i*3+2]*R[2*3  ];
    P[i*4+1]=K[i*3]*R[1] + K[i*3+1]*R[1*3+1] + K[i*3+2]*R[2*3+1];
    P[i*4+2]=K[i*3]*R[2] + K[i*3+1]*R[1*3+2] + K[i*3+2]*R[2*3+2];

    P[i*4+3]=K[i*3]*t[0] + K[i*3+1]*t[1] + K[i*3+2]*t[2];
  }
}

/* as above for a rotation matrix;
 * compute the projection matrix corresponding to intrinsics in K and motion R, t: P=K*[R t] */
void sam_PfromKRt(double K[9], double R[9], double t[3], double P[12])
{
register int i;

  /* P=[K*R | K*t] */
  for(i=0; i<3; ++i){
    P[i*4  ]=K[i*3]*R[0] + K[i*3+1]*R[1*3  ] + K[i*3+2]*R[2*3  ];
    P[i*4+1]=K[i*3]*R[1] + K[i*3+1]*R[1*3+1] + K[i*3+2]*R[2*3+1];
    P[i*4+2]=K[i*3]*R[2] + K[i*3+1]*R[1*3+2] + K[i*3+2]*R[2*3+2];

    P[i*4+3]=K[i*3]*t[0] + K[i*3+1]*t[1] + K[i*3+2]*t[2];
  }
}

/* 3x3 QR factorization, based on qr.cpp https://gist.github.com/ReaperUnreal/3961408 */
#define _SIGN(x) ( ((x)>0.0)? 1.0 : ( ((x)<0.0)? -1.0 : 0.0) )
static void sam_qr3x3(double *mat, double *q, double *r)
{
double q1[9], q2[9], res1[9];

  //printMatrix3x3(mat);

  //getQ1(mat, q1);
  {
    double x[3], magx;
    double alpha, u[3], magu, v[3];

    x[0] = mat[0]; x[1] = mat[3]; x[2] = mat[6];
    //printf("x = [%0.6lf, %0.6lf, %0.6lf]\n", x[0], x[1], x[2]);

    magx = sqrt(x[0]*x[0] + x[1]*x[1] + x[2]*x[2]);
    //printf("magx = %0.6lf\n", magx);

    alpha = magx * -1.0 * _SIGN(mat[0]); //alpha = ||x|| * sign(xk)
    //printf("alpha = %0.6lf\n", alpha);

    u[0] = x[0] + alpha; u[1] = x[1]; u[2] = x[2]; //u = x + alpha * e1
    //printf("u = [%0.6lf, %0.6lf, %0.6lf]\n", u[0], u[1], u[2]);

    magu = sqrt(u[0]*u[0] + u[1]*u[1] + u[2]*u[2]);
    //printf("magu = %0.6lf\n", magu);
    if(magu >= 1E+3*DBL_MIN){
      magu = 1.0 / magu;
      v[0] = u[0] * magu; v[1] = u[1] * magu; v[2] = u[2] * magu; //v = u / ||u||
    }
    else
      v[0] = v[1] = v[2] = 0.0;
    //printf("v = [%0.6lf, %0.6lf, %0.6lf]\n", v[0], v[1], v[2]);

    //q = I - 2vvT
    q1[0] = 1 - 2 * v[0] * v[0]; q1[1] =    -2 * v[0] * v[1]; q1[2] =    -2 * v[0] * v[2];
    q1[3] =    -2 * v[0] * v[1]; q1[4] = 1 - 2 * v[1] * v[1]; q1[5] =    -2 * v[1] * v[2];
    q1[6] =    -2 * v[0] * v[2]; q1[7] =    -2 * v[1] * v[2]; q1[8] = 1 - 2 * v[2] * v[2];
  }

  //printMatrix3x3(q1);
  /* res1 = q1*mat */
  res1[0] = q1[0] * mat[0] + q1[1] * mat[3] + q1[2] * mat[6];
  res1[1] = q1[0] * mat[1] + q1[1] * mat[4] + q1[2] * mat[7];
  res1[2] = q1[0] * mat[2] + q1[1] * mat[5] + q1[2] * mat[8];
  res1[3] = q1[3] * mat[0] + q1[4] * mat[3] + q1[5] * mat[6];
  res1[4] = q1[3] * mat[1] + q1[4] * mat[4] + q1[5] * mat[7];
  res1[5] = q1[3] * mat[2] + q1[4] * mat[5] + q1[5] * mat[8];
  res1[6] = q1[6] * mat[0] + q1[7] * mat[3] + q1[8] * mat[6];
  res1[7] = q1[6] * mat[1] + q1[7] * mat[4] + q1[8] * mat[7];
  res1[8] = q1[6] * mat[2] + q1[7] * mat[5] + q1[8] * mat[8];
  //printMatrix3x3(res1);

  //getQ2(res1, q2);
  {
    double x[2], magx;
    double alpha, u[2], magu, v[2];

    x[0] = res1[4]; x[1] = res1[7];
    magx = sqrt(x[0]*x[0] + x[1]*x[1]);
    alpha = magx * -1.0 * _SIGN(res1[4]); //alpha = ||x|| * sign(xk)

    u[0] = x[0] + alpha; u[1] = x[1]; //u = x + alpha * e1

    magu = sqrt(u[0]*u[0] + u[1]*u[1]);
    if(magu >= 1E+3*DBL_MIN){
      magu = 1.0 / magu;
      v[0] = u[0] * magu; v[1] = u[1] * magu; //v = u / ||u||
    }
    else
      v[0] = v[1] = 0.0;

    //q = I - 2vvT
    q2[0] = 1; q2[1] = 0; q2[2] = 0;
    q2[3] = 0; q2[4] = 1 - 2 * v[0] * v[0]; q2[5] =    -2 * v[0] * v[1];
    q2[6] = 0; q2[7] =    -2 * v[0] * v[1]; q2[8] = 1 - 2 * v[1] * v[1];
  }

  //printMatrix3x3(q2);
  /* r = q2*res1 */
  r[0] = q2[0] * res1[0] + q2[1] * res1[3] + q2[2] * res1[6];
  r[1] = q2[0] * res1[1] + q2[1] * res1[4] + q2[2] * res1[7];
  r[2] = q2[0] * res1[2] + q2[1] * res1[5] + q2[2] * res1[8];
  r[3] = q2[3] * res1[0] + q2[4] * res1[3] + q2[5] * res1[6];
  r[4] = q2[3] * res1[1] + q2[4] * res1[4] + q2[5] * res1[7];
  r[5] = q2[3] * res1[2] + q2[4] * res1[5] + q2[5] * res1[8];
  r[6] = q2[6] * res1[0] + q2[7] * res1[3] + q2[8] * res1[6];
  r[7] = q2[6] * res1[1] + q2[7] * res1[4] + q2[8] * res1[7];
  r[8] = q2[6] * res1[2] + q2[7] * res1[5] + q2[8] * res1[8];
  //printMatrix3x3(r);

  /* q=q1^t*q2^t */
  q[0] = q1[0] * q2[0] + q1[3] * q2[1] + q1[6] * q2[2];
  q[1] = q1[0] * q2[3] + q1[3] * q2[4] + q1[6] * q2[5];
  q[2] = q1[0] * q2[6] + q1[3] * q2[7] + q1[6] * q2[8];
  q[3] = q1[1] * q2[0] + q1[4] * q2[1] + q1[7] * q2[2];
  q[4] = q1[1] * q2[3] + q1[4] * q2[4] + q1[7] * q2[5];
  q[5] = q1[1] * q2[6] + q1[4] * q2[7] + q1[7] * q2[8];
  q[6] = q1[2] * q2[0] + q1[5] * q2[1] + q1[8] * q2[2];
  q[7] = q1[2] * q2[3] + q1[5] * q2[4] + q1[8] * q2[5];
  q[8] = q1[2] * q2[6] + q1[5] * q2[7] + q1[8] * q2[8];
  //printMatrix3x3(q);
}
#undef _SIGN

/* 3x3 RQ factorization, based on vgg_rq.m 
 * see also http://www.mathworks.com/matlabcentral/newsreader/view_thread/237007
 */
static void sam_rq3x3(double *mat, double *r, double *q)
{
double flmat[9], flq[9], flr[9];

  flmat[0] = mat[8]; flmat[1] = mat[5]; flmat[2] = mat[2];
  flmat[3] = mat[7]; flmat[4] = mat[4]; flmat[5] = mat[1];
  flmat[6] = mat[6]; flmat[7] = mat[3]; flmat[8] = mat[0];

  sam_qr3x3(flmat, flq, flr);

  q[0] = flq[8]; q[1] = flq[5]; q[2] = flq[2];
  q[3] = flq[7]; q[4] = flq[4]; q[5] = flq[1];
  q[6] = flq[6]; q[7] = flq[3]; q[8] = flq[0];

  r[0] = flr[8]; r[1] = flr[5]; r[2] = flr[2];
  r[3] = flr[7]; r[4] = flr[4]; r[5] = flr[1];
  r[6] = flr[6]; r[7] = flr[3]; r[8] = flr[0];

#if 0 // following fragment ensures det(q)=1
  if(sam_det3x3(q)<0.0){
    r[0]=-r[0]; r[3]=-r[3]; r[6]=-r[6];
    q[0]=-q[0]; q[1]=-q[1]; q[2]=-q[2];
  }
#endif
}

/* Extract K, R, t from a finite, metric projection matrix
 * using RQ decomposition. see HZ pp.150, 552
 *
 * Returns 1 on error (camera at infinity), 0 otherwise
 *
 * This is a LAPACK-free implementation of sam_KRtfromP_lapack() above.
 */
int sam_KRtfromP(double P[12], double K[9], double R[9], double t[3])
{
double lam;
double M[9], tmp1[9], tmp2[9];
register int i;

 /* if P=[M|a] then M=RQ, with R corresponding to the intrinsic
  * camera parameters (K) and Q to the camera rotation (R)
  */

  /* M=P(:, 1:3) */
  M[0]=P[0]; M[1]=P[1]; M[2]=P[2];
  M[3]=P[4]; M[4]=P[5]; M[5]=P[6];
  M[6]=P[8]; M[7]=P[9]; M[8]=P[10];

  lam=sam_det3x3(M);
  if(-1E+3*DBL_MIN<=lam && lam<=1E+3*DBL_MIN) return 1; /* camera is not finite */

  /* RQ decomposition; the orthogonal matrix corresponds to R */
  sam_rq3x3(M, K, R);

  /* ensure that K(3, 3)=1.0.
   * Note that the effect of multiplying K by lambda
   * is to multiply the projection matrix [K R | K t] by
   * lambda. Since K is not involved in any calculations
   * in this function, no further action needs to be taken
   */
  lam=1.0/K[8];
  K[0]*=lam; K[1]*=lam; K[2]*=lam;
  K[3]*=lam; K[4]*=lam; K[5]*=lam;
  K[6]*=lam; K[7]*=lam; K[8]*=lam;

  /* ensure that K has positive diagonal entries in the first two columns.
   * Note that the effect of multiplying column i of K by -1
   * can be canceled out by multiplying row i of R by -1
   */
  for(i=0; i<2; i++)
    if(K[i*3+i]<0.0){
        K[0*3+i]=-K[0*3+i];
        R[i*3+0]=-R[i*3+0];

        K[1*3+i]=-K[1*3+i];
        R[i*3+1]=-R[i*3+1];

        K[2*3+i]=-K[2*3+i];
        R[i*3+2]=-R[i*3+2];
    }

  /* ensure that det(R)=1 */
  lam=sam_det3x3(R);
  if(lam<0.0){
    R[0]=-R[0]; R[1]=-R[1]; R[2]=-R[2];
    R[3]=-R[3]; R[4]=-R[4]; R[5]=-R[5];
    R[6]=-R[6]; R[7]=-R[7]; R[8]=-R[8];
  }

  /* find the translation as R*M^-1*p4, where p4 is the fourth column of P.
   * Note that M^-1*p4 is the camera center; see HZ pp. 143, 145
   */
  if(t){
    /* tmp1 = M^-1 */
    sam_inv3x3(M, tmp1);
    /* tmp2 = R*M^-1 */
    tmp2[0]=R[0]*tmp1[0] + R[1]*tmp1[3] + R[2]*tmp1[6];
    tmp2[1]=R[0]*tmp1[1] + R[1]*tmp1[4] + R[2]*tmp1[7];
    tmp2[2]=R[0]*tmp1[2] + R[1]*tmp1[5] + R[2]*tmp1[8];
    tmp2[3]=R[3]*tmp1[0] + R[4]*tmp1[3] + R[5]*tmp1[6];
    tmp2[4]=R[3]*tmp1[1] + R[4]*tmp1[4] + R[5]*tmp1[7];
    tmp2[5]=R[3]*tmp1[2] + R[4]*tmp1[5] + R[5]*tmp1[8];
    tmp2[6]=R[6]*tmp1[0] + R[7]*tmp1[3] + R[8]*tmp1[6];
    tmp2[7]=R[6]*tmp1[1] + R[7]*tmp1[4] + R[8]*tmp1[7];
    tmp2[8]=R[6]*tmp1[2] + R[7]*tmp1[5] + R[8]*tmp1[8];

    t[0]=tmp2[0]*P[3] + tmp2[1]*P[7] + tmp2[2]*P[11];
    t[1]=tmp2[3]*P[3] + tmp2[4]*P[7] + tmp2[5]*P[11];
    t[2]=tmp2[6]*P[3] + tmp2[7]*P[7] + tmp2[8]*P[11];
  }

  return 0;
}

/* Given the projection matrices P0, P1, calculate the fundamental matrix F
 * compatible with them. First, the matrices are canonicalized to [I | 0], [M | a]
 * and F is computed as F=[a]x M
 *
 * If P0 is NULL, then matrix P1 is assumed to be canonicalized, i.e. P0 is
 * implied to be [I | 0]
*/

void sam_FfromPs(double P0[12], double P1[12], double F[9])
{
double ax[3*3]={0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
        M[3*3]={0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
        H[4*4]={0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0},
        nP1[3*4];

double a0, a1, a2, *sP1;
register int i;

  if(P0){
    double M1[3*3];

    /* find the homography that will convert P0, P1 to the canonical form:
     * if P0 = [ M | b], then H = [M^-1 | -M^-1*b; 0 0 0 1], see HZ p.235
     * P1 transforms as P1*H
     */

    /* extract M */
    M[0]=P0[0]; M[1]=P0[1]; M[2]=P0[2];
    M[3]=P0[4]; M[4]=P0[5]; M[5]=P0[6];
    M[6]=P0[8]; M[7]=P0[9]; M[8]=P0[10];

    sam_inv3x3(M, M1); // M1=M^-1

    /* set H's 3x3 submatrix to M1 */
    H[0]=M1[0]; H[1]=M1[1]; H[2]=M1[2];
    H[4]=M1[3]; H[5]=M1[4]; H[6]=M1[5];
    H[8]=M1[6]; H[9]=M1[7]; H[10]=M1[8];

    /* set H's 4th column to M1*P0_4, P0_4 being the 4th column of P0 */
    H[3] =-(M1[0]*P0[3] + M1[1]*P0[7] + M1[2]*P0[11]);
    H[7] =-(M1[3]*P0[3] + M1[4]*P0[7] + M1[5]*P0[11]);
    H[11]=-(M1[6]*P0[3] + M1[7]*P0[7] + M1[8]*P0[11]);

    /* set H's 4th row */
    H[12]=H[13]=H[14]=0.0; H[15]=1.0;

    /* nP1=P1*H */
    for(i=0; i<3; ++i){
      nP1[i*4  ]=P1[i*4]*H[0] + P1[i*4+1]*H[1*4  ] + P1[i*4+2]*H[2*4  ] + P1[i*4+3]*H[3*4  ];
      nP1[i*4+1]=P1[i*4]*H[1] + P1[i*4+1]*H[1*4+1] + P1[i*4+2]*H[2*4+1] + P1[i*4+3]*H[3*4+1];
      nP1[i*4+2]=P1[i*4]*H[2] + P1[i*4+1]*H[1*4+2] + P1[i*4+2]*H[2*4+2] + P1[i*4+3]*H[3*4+2];
      nP1[i*4+3]=P1[i*4]*H[3] + P1[i*4+1]*H[1*4+3] + P1[i*4+2]*H[2*4+3] + P1[i*4+3]*H[3*4+3];
    }
    sP1=nP1;
  }
  else
    sP1=P1;

  /* compute [a]x */
  a0=sP1[3]; a1=sP1[7]; a2=sP1[11];

  ax[0]=0.0; ax[1]=-a2; ax[2]=a1;
  ax[3]=a2;  ax[4]=0.0; ax[5]=-a0;
  ax[6]=-a1; ax[7]=a0;  ax[8]=0.0;

  /* extract M */
  M[0]=sP1[0]; M[1]=sP1[1]; M[2]=sP1[2];
  M[3]=sP1[4]; M[4]=sP1[5]; M[5]=sP1[6];
  M[6]=sP1[8]; M[7]=sP1[9]; M[8]=sP1[10];

  /* F=ax*M */
  for(i=0; i<3; ++i){
    F[i*3  ]=ax[i*3]*M[0] + ax[i*3+1]*M[1*3  ] + ax[i*3+2]*M[2*3  ];
    F[i*3+1]=ax[i*3]*M[1] + ax[i*3+1]*M[1*3+1] + ax[i*3+2]*M[2*3+1];
    F[i*3+2]=ax[i*3]*M[2] + ax[i*3+1]*M[1*3+2] + ax[i*3+2]*M[2*3+2];
  }
}

/* Compute the camera center as the null vector c of the camera matrix P:
 * P*c = 0
 *
 * For a finite camera P=K*R[I | -C], t=-R*C with C=c(1:3)./c(4)
 */
void sam_PCent(double P[12], double c[4])
{
int three=3, four=4, lwork=64; /* probably too much here...*/
double Pt[12]; /* matrix in column major order */
double S[3], Vt[4][4], work[64];
//double U[3][3];
int info;

  /* transpose */
  Pt[0]=P[0]; Pt[1]= P[4];  Pt[2]= P[8];
  Pt[3]=P[1]; Pt[4]= P[5];  Pt[5]= P[9];
  Pt[6]=P[2]; Pt[7]= P[6];  Pt[8]= P[10];
  Pt[9]=P[3]; Pt[10]=P[7];  Pt[11]=P[11];

  /* call LAPACK SVD */
  F77_FUNC(dgesvd)("N", "A", &three, &four, Pt, &three, S, NULL, &three, Vt[0], &four, work, &lwork, &info);

  if(info<0){
    fprintf(stderr, "LAPACK error: illegal value for argument %d of dgesvd in sam_PCent()\n", -info);
    exit(1);
  }
  else if(info>0){
    fprintf(stderr, "LAPACK error: dbdsqr did not converge in sam_PCent();\n%d %s", info,
    "superdiagonals of an intermediate bidiagonal form did not converge to zero\n");
    exit(1);
  }

  /* c is the last column of Vt */
  c[0]=Vt[0][3];
  c[1]=Vt[1][3];
  c[2]=Vt[2][3];
  c[3]=Vt[3][3];
}

/*
 * Compute the camera intrinsics K given the focal length (mm),
 * the imaging sensor dimensions in senssz (mm) and the image size
 * in imgsz (pixels).
 *
 * If not NULL, ppt specifies the coordinates of the principal point
 * in pixels, set to the image center otherwise and sk specifies the
 * skew, typically 0.
 *
 * Dimensions of standard CCDs:
 * 1/6",   [2.4, 1.8]
 * 1/4",   [3.2, 2.4]
 * 1/3",   [4.8, 3.6]
 * 1/2.7", [5.371, 4.035]
 * 1/2.5", [5.76, 4.29]
 * 1/2",   [6.4, 4.8]
 * 1/1.8", [7.18, 5.32]
 * 1/1.7", [7.6, 5.7]
 * 2/3",   [8.8, 6.6]
 * 1"  ,   [12.8, 9.6]
 * 4/3",   [18.0, 13.5]
 * 1.8",   [23.7, 15.7]
 * 35mm,  [36.0, 24.0]
 */
void sam_KfromSensor(double foc, double senssz[2], int imgsz[2], double ppt[2], double sk, double K[9])
{
double pixW, pixH; // pixel size
double x0, y0;

  /* senssz[0] is the sensor's largest dimension, following check ensures
   * correctness even if the camera is rotated 90 degrees sideways
   */

  if(imgsz[0]>=imgsz[1]){
    pixW=senssz[0]/(double)imgsz[0];
    pixH=senssz[1]/(double)imgsz[1];
  }else{
    pixW=senssz[1]/(double)imgsz[0];
    pixH=senssz[0]/(double)imgsz[1];
  }

  if(!ppt){
    x0=imgsz[0]*0.5;
    y0=imgsz[1]*0.5;
  }
  else{
    x0=ppt[0];
    y0=ppt[1];
  }

  K[0]=foc/pixW; K[1]=sk;       K[2]=x0;
  K[3]=0.0;      K[4]=foc/pixH; K[5]=y0;
  K[6]=0.0;      K[7]=0.0;      K[8]=1.0;
}

/* compute the positional and angular error between the rigid motions defined by r,t and rg,tg */
#define _clamp(a, b, x) ( ((x)<=(a))? (a) : (((x)<=(b))? (x) : (b)) )
void sam_rtErr(double r[3], double t[3], double rg[3], double tg[3], double *terr, double *aerr)
{
double a, b, c;
double Rg[9], R[9], trc;

  /* positional error */
  if(terr){
    a=tg[0]-t[0];
    b=tg[1]-t[1];
    c=tg[2]-t[2];
    *terr=sqrt(a*a + b*b + c*c);
  }

  /* angular error, defined as the amount of rotation about a unit vector that transfers Rg to R.
   * The (residual) angle is computed with the inverse Rodrigues rotation formula
   */
  if(aerr){
    sam_vec2rotmat(rg, Rg);
    sam_vec2rotmat(r, R);

    /* compute trc as the trace of Rg'*R */
    a=Rg[0]*R[0] + Rg[3]*R[3] + Rg[6]*R[6];
    b=Rg[1]*R[1] + Rg[4]*R[4] + Rg[7]*R[7];
    c=Rg[2]*R[2] + Rg[5]*R[5] + Rg[8]*R[8];
    trc=a+b+c;
    a=0.5*(trc-1.0);
    *aerr=acos(_clamp(-1.0, 1.0, a));
  }
}
#undef _clamp

/* As above with a different definition of pose errors:
 * the relative rotation and translation errors are computed as in 
 * "Accurate Non-Iterative O(n) Solution to the PnP Problem",
 * by Moreno-Noguer et al. (using quaternions for rotations)
 *
 * The errors are computed as
 * |rtrue-rest|/|rtrue|,  |ttrue-test|/|ttrue|
 */
void sam_rtErrRel(double rest[3], double test[3], double rtrue[3], double ttrue[3], double *terr, double *rerr)
{
double rerr1, rerr2, denom;

  denom=(rtrue[0]*rtrue[0] + rtrue[1]*rtrue[1] + rtrue[2]*rtrue[2]);

  rerr1=sqrt((
      (rtrue[0] - rest[0])*(rtrue[0] - rest[0]) +
      (rtrue[1] - rest[1])*(rtrue[1] - rest[1]) +
      (rtrue[2] - rest[2])*(rtrue[2] - rest[2]) ) / denom);

  /* take care of possibly erroneous sign */
  rerr2=sqrt((
      (rtrue[0] + rest[0])*(rtrue[0] + rest[0]) +
      (rtrue[1] + rest[1])*(rtrue[1] + rest[1]) +
      (rtrue[2] + rest[2])*(rtrue[2] + rest[2]) ) / denom);

  *rerr=(rerr1<=rerr2)? rerr1 : rerr2; //min(rerr1, rerr2);

  *terr=sqrt((
      (ttrue[0] - test[0])*(ttrue[0] - test[0]) +
      (ttrue[1] - test[1])*(ttrue[1] - test[1]) +
      (ttrue[2] - test[2])*(ttrue[2] - test[2])) /
      (ttrue[0]*ttrue[0] + ttrue[1]*ttrue[1] + ttrue[2]*ttrue[2]) );
}

/* Absolute orientation with the unit quaternion method
 *
 * see Horn, "Closed-form Solution of Absolute Orientation Using Unit Quaternions",
 * JOSAA (4):4, 1987, pp.629
 *
 * Given two corresponding point sets pts0, pts1, computes R, t, sc such that
 * pts1 = R sc*pts0 + t
 * Note that pts1 = R sc*pts0 + t <==> pts1/sc = R*pts0 + t/sc
 * If the caller sets sc to NULL, then the scale is assumed fixed and equal to 1.0
 *
 * An indx!=NULL specifies the indices of corresponding points that should be
 * considered; all points are used otherwise (no mismatches are tolerated)
 *
 * returns 0 on success, nonzero otherwise
 */
int sam_absorq(double (*pts0)[3], double (*pts1)[3], int *indx, int npts, double R[9], double t[3], double *sc)
{
register int i;
double pc[3], qc[3], p[3], q[3], M[4][4], *dptr, one_over_npts, dpsum, dqsum, scale=1.0;
double Sxx, Sxy, Sxz, Syx, Syy, Syz, Szx, Szy, Szz;
double eigvals[4], *eigvecs=(double *)M;
register double *x;
int nvars=4, info;

  if(npts<3){
    fprintf(stderr, "At least 3 points are necessary for estimating absolute orientation in sam_absorq()! [%d]\n", npts); fflush(stderr);
    memset(R, 0, 9*sizeof(double));
    if(t) memset(t, 0, 3*sizeof(double));

    return 1;
  }

  pc[0]=pc[1]=pc[2]=
  qc[0]=qc[1]=qc[2]=0.0;
  one_over_npts=1.0/(double)(npts);
  Sxx=Syy=Szz=Syz=Szy=Szx=Sxz=Sxy=Syx=0.0;
  dpsum=dqsum=0.0;
	
  if(!indx){
    /* compute centroids */
    for(i=0; i<npts; i++){
      dptr=pts0[i];
      pc[0]+=*dptr++; pc[1]+=*dptr++; pc[2]+=*dptr;

      dptr=pts1[i];
      qc[0]+=*dptr++; qc[1]+=*dptr++; qc[2]+=*dptr;
    }

    pc[0]*=one_over_npts; pc[1]*=one_over_npts; pc[2]*=one_over_npts;
    qc[0]*=one_over_npts; qc[1]*=one_over_npts; qc[2]*=one_over_npts;

    /* compute the S,, from p', q' */
    for(i=0; i<npts; i++){
      dptr=pts0[i];
      p[0]=*dptr++ - pc[0];
      p[1]=*dptr++ - pc[1];
      p[2]=*dptr   - pc[2];
      dpsum+=p[0]*p[0] + p[1]*p[1] + p[2]*p[2];

      dptr=pts1[i];
      q[0]=*dptr++ - qc[0];
      q[1]=*dptr++ - qc[1];
      q[2]=*dptr   - qc[2];
      dqsum+=q[0]*q[0] + q[1]*q[1] + q[2]*q[2];

      Sxx+=p[0]*q[0]; Sxy+=p[0]*q[1]; Sxz+=p[0]*q[2];
      Syx+=p[1]*q[0]; Syy+=p[1]*q[1]; Syz+=p[1]*q[2];
      Szx+=p[2]*q[0]; Szy+=p[2]*q[1]; Szz+=p[2]*q[2];
    }
  }
  else{
    /* compute centroids */
    for(i=0; i<npts; i++){
      dptr=pts0[indx[i]];
      pc[0]+=*dptr++; pc[1]+=*dptr++; pc[2]+=*dptr;

      dptr=pts1[indx[i]];
      qc[0]+=*dptr++; qc[1]+=*dptr++; qc[2]+=*dptr;
    }

    pc[0]*=one_over_npts; pc[1]*=one_over_npts; pc[2]*=one_over_npts;
    qc[0]*=one_over_npts; qc[1]*=one_over_npts; qc[2]*=one_over_npts;

    /* compute the S,, from p', q' */
    for(i=0; i<npts; i++){
      dptr=pts0[indx[i]];
      p[0]=*dptr++ - pc[0];
      p[1]=*dptr++ - pc[1];
      p[2]=*dptr   - pc[2];
      dpsum+=p[0]*p[0] + p[1]*p[1] + p[2]*p[2];

      dptr=pts1[indx[i]];
      q[0]=*dptr++ - qc[0];
      q[1]=*dptr++ - qc[1];
      q[2]=*dptr   - qc[2];
      dqsum+=q[0]*q[0] + q[1]*q[1] + q[2]*q[2];

      Sxx+=p[0]*q[0]; Sxy+=p[0]*q[1]; Sxz+=p[0]*q[2];
      Syx+=p[1]*q[0]; Syy+=p[1]*q[1]; Syz+=p[1]*q[2];
      Szx+=p[2]*q[0]; Szy+=p[2]*q[1]; Szz+=p[2]*q[2];
    }
  }

  { double tmp;

    tmp=sqrt(dqsum/dpsum); // see also Eq.(39) in Lu et al.

    if(sc!=NULL)
      *sc=scale=tmp;
    else{
      if(fabs((1.0-tmp)/tmp)>1E-03)
        fprintf(stderr, "Warning: unit scale requested from sam_absorq() but that estimated from the data is %.15g\n", tmp);
    }
  }

  /* M is symmetric, hence only its upper triangle is computed. Note that in column-major, this corresponds to the lower triangle */
  M[0][0]=Sxx + Syy + Szz; M[0][1]=Syz - Szy;       M[0][2]=Szx - Sxz;        M[0][3]=Sxy - Syx;
                           M[1][1]=Sxx - Syy - Szz; M[1][2]=Sxy + Syx;        M[1][3]=Szx + Sxz;
                                                    M[2][2]=-Sxx + Syy - Szz; M[2][3]=Syz + Szy;
                                                                              M[3][3]=-Sxx - Syy + Szz;

#if 1
  {
    double work[136];
    int lwork=136; // optimal size determined by querying with lwork==-1

    F77_FUNC(dsyev)("V", "L", &nvars, (double *)M, &nvars, eigvals, work, &lwork, &info);
  }
#else
  {
    double triang[10], work[12];
    register int j;

    for(j=0; j<4; j++)
      for(i=0; i<=j; i++) // copy M's upper triangle
        triang[i + ((j*(j+1))>> 1)]=M[i][j]; // i + j*(j+1)/2
    
    F77_FUNC(dspev)("V", "U", &nvars, triang, eigvals, eigvecs, &nvars, work, &info);
  }
#endif

  if(info<0){
    fprintf(stderr, "LAPACK error: illegal value for argument %d of dspev/dsyev in sam_absorq()\n", -info);
    exit(1);
  }
  else if(info>0){
    fprintf(stderr, "LAPACK error: dspev/dsyev failed to converge in sam_absorq();\n%d %s", info,
        "off-diagonal elements of an intermediate tridiagonal form did not converge to zero\n");
    memset(R, 0, 9*sizeof(double));
    if(t) memset(t, 0, 3*sizeof(double));

    return 1;
  }

  /* eigenvalues are returned in ascending order, therefore the largest is the last one */
  x=eigvecs + 4*3;

  /* x points to the computed quaternion; by computation it has a unit length */

  /* compute the rotation matrix corresponding to the estimated quaternion */
  R[0]=x[0]*x[0]+x[1]*x[1]-x[2]*x[2]-x[3]*x[3];
  R[1]=2*(x[1]*x[2]-x[0]*x[3]);
  R[2]=2*(x[1]*x[3]+x[0]*x[2]);

  R[3]=2*(x[1]*x[2]+x[0]*x[3]);
  R[4]=x[0]*x[0]+x[2]*x[2]-x[1]*x[1]-x[3]*x[3];
  R[5]=2*(x[2]*x[3]-x[0]*x[1]);

  R[6]=2*(x[1]*x[3]-x[0]*x[2]);
  R[7]=2*(x[2]*x[3]+x[0]*x[1]);
  R[8]=x[0]*x[0]+x[3]*x[3]-x[1]*x[1]-x[2]*x[2];

  if(!t) return 0;

  if(sc!=NULL){
    /* t = qc - R sc*pc */
    t[0]=qc[0] - scale*(R[0]*pc[0] + R[1]*pc[1] + R[2]*pc[2]);
    t[1]=qc[1] - scale*(R[3]*pc[0] + R[4]*pc[1] + R[5]*pc[2]);
    t[2]=qc[2] - scale*(R[6]*pc[0] + R[7]*pc[1] + R[8]*pc[2]);
  }
  else{
    /* t = qc - R *pc */
    t[0]=qc[0] - (R[0]*pc[0] + R[1]*pc[1] + R[2]*pc[2]);
    t[1]=qc[1] - (R[3]*pc[0] + R[4]*pc[1] + R[5]*pc[2]);
    t[2]=qc[2] - (R[6]*pc[0] + R[7]*pc[1] + R[8]*pc[2]);
  }

  return 0;
}


/* Absolute orientation with the SVD method
 *
 * see Horn, Hilden & Negahdaripour "Closed-Form Solution of Absolute Orientation
 * Using Orthonormal Matrices", JOSAA (5), 1988, pp. 1127-1135,
 *
 * Arun, Huang & Blostein "Least-Squares Fitting of Two 3-D Point Sets",
 * PAMI 9:(5), 1987, p. 698-700
 *
 * and
 *
 * Lu, Hager & Mjolsness "Fast and Globally Convergent Pose Estimation
 * from Video Images", PAMI (22):6, 2000, pp.613
 *
 * Given two corresponding point sets pts0, pts1, computes R, t, sc such that
 * pts1 = R sc*pts0 + t
 * If the caller sets sc to NULL, then the scale is assumed fixed and equal to 1.0
 *
 * An indx!=NULL specifies the indices of corresponding points that should be
 * considered; all points are used otherwise (no mismatches are tolerated)
 *
 * returns 0 on success, nonzero otherwise
 */
int sam_absorsvd(double (*pts0)[3], double (*pts1)[3], int *indx, int npts, double R[9], double t[3], double *sc)
{
register int i;
double pc[3], qc[3], p[3], q[3], M[3][3], *dptr, one_over_npts, dpsum, dqsum, scale=1.0, tmp;
double S[3], U[3][3], Vt[3][3], work[32]; /* SVD stuff */
int three=3, lwork=32; /* probably too much here...*/
int info;

  if(npts<3){
    fprintf(stderr, "At least 3 points are necessary for estimating absolute orientation in sam_absorsvd()! [%d]\n", npts); fflush(stderr);
    memset(R, 0, 9*sizeof(double));
    if(t) memset(t, 0, 3*sizeof(double));

    return 1;
  }

  pc[0]=pc[1]=pc[2]=
  qc[0]=qc[1]=qc[2]=0.0;
  one_over_npts=1.0/(double)(npts);
  dpsum=dqsum=0.0;
  M[0][0]=M[0][1]=M[0][2]=
  M[1][0]=M[1][1]=M[1][2]=
  M[2][0]=M[2][1]=M[2][2]=0.0;
	
  /* Note: LHM erroneously define M in Eq.(13) as \sum_i q'_i*p't_i; the former is
   * the transpose of M, M is actually \sum_i p'_i*q't_i. See also Arun et al.
   */
  if(!indx){
    /* compute centroids */
    for(i=0; i<npts; i++){
      dptr=pts0[i];
      pc[0]+=*dptr++; pc[1]+=*dptr++; pc[2]+=*dptr;

      dptr=pts1[i];
      qc[0]+=*dptr++; qc[1]+=*dptr++; qc[2]+=*dptr;
    }

    pc[0]*=one_over_npts; pc[1]*=one_over_npts; pc[2]*=one_over_npts;
    qc[0]*=one_over_npts; qc[1]*=one_over_npts; qc[2]*=one_over_npts;

    /* compute M from p', q' */
    for(i=0; i<npts; i++){
      dptr=pts0[i];
      p[0]=*dptr++ - pc[0];
      p[1]=*dptr++ - pc[1];
      p[2]=*dptr   - pc[2];
      dpsum+=p[0]*p[0] + p[1]*p[1] + p[2]*p[2];

      dptr=pts1[i];
      q[0]=*dptr++ - qc[0];
      q[1]=*dptr++ - qc[1];
      q[2]=*dptr   - qc[2];
      dqsum+=q[0]*q[0] + q[1]*q[1] + q[2]*q[2];

      /* compute \sum_i q'_i*p't_i which is M in column major */
      M[0][0]+=q[0]*p[0]; M[0][1]+=q[0]*p[1]; M[0][2]+=q[0]*p[2];
      M[1][0]+=q[1]*p[0]; M[1][1]+=q[1]*p[1]; M[1][2]+=q[1]*p[2];
      M[2][0]+=q[2]*p[0]; M[2][1]+=q[2]*p[1]; M[2][2]+=q[2]*p[2];
    }
  }
  else{
    /* compute centroids */
    for(i=0; i<npts; i++){
      dptr=pts0[indx[i]];
      pc[0]+=*dptr++; pc[1]+=*dptr++; pc[2]+=*dptr;

      dptr=pts1[indx[i]];
      qc[0]+=*dptr++; qc[1]+=*dptr++; qc[2]+=*dptr;
    }

    pc[0]*=one_over_npts; pc[1]*=one_over_npts; pc[2]*=one_over_npts;
    qc[0]*=one_over_npts; qc[1]*=one_over_npts; qc[2]*=one_over_npts;

    /* compute M from p', q' */
    for(i=0; i<npts; i++){
      dptr=pts0[indx[i]];
      p[0]=*dptr++ - pc[0];
      p[1]=*dptr++ - pc[1];
      p[2]=*dptr   - pc[2];
      dpsum+=p[0]*p[0] + p[1]*p[1] + p[2]*p[2];

      dptr=pts1[indx[i]];
      q[0]=*dptr++ - qc[0];
      q[1]=*dptr++ - qc[1];
      q[2]=*dptr   - qc[2];
      dqsum+=q[0]*q[0] + q[1]*q[1] + q[2]*q[2];

      /* compute \sum_i q'_i*p't_i which is M in column major */
      M[0][0]+=q[0]*p[0]; M[0][1]+=q[0]*p[1]; M[0][2]+=q[0]*p[2];
      M[1][0]+=q[1]*p[0]; M[1][1]+=q[1]*p[1]; M[1][2]+=q[1]*p[2];
      M[2][0]+=q[2]*p[0]; M[2][1]+=q[2]*p[1]; M[2][2]+=q[2]*p[2];
    }
  }

  tmp=sqrt(dqsum/dpsum); // see also Eq.(39) in Lu et al.

  if(sc!=NULL)
    *sc=scale=tmp;
  else{
    if(fabs((1.0-tmp)/tmp)>1E-03)
      fprintf(stderr, "Warning: unit scale requested from sam_absorsvd() but that estimated from the data is %.15g\n", tmp);
  }

  /* note that M has been computed above in column-major order */

#if 0 // use custom 3x3 SVD
    svd3(U[0], S, Vt[0], M[0]);
    /* svd3 actually returns V; for compatibility with LAPACK which returns V^T,
     * the computed Vt is transposed in place to yield the true Vt
     */
    tmp=Vt[0][1]; Vt[0][1]=Vt[1][0]; Vt[1][0]=tmp;
    tmp=Vt[0][2]; Vt[0][2]=Vt[2][0]; Vt[2][0]=tmp;
    tmp=Vt[1][2]; Vt[1][2]=Vt[2][1]; Vt[2][1]=tmp;
#else // use generic SVD
  F77_FUNC(dgesvd)("A", "A", &three, &three, M[0], &three, S, U[0], &three, Vt[0], &three, work, &lwork, &info);
  if(info<0){
    fprintf(stderr, "LAPACK error: illegal value for argument %d of dgesvd in sam_absorsvd()\n", -info);
    exit(1);
  }
  else if(info>0){
    fprintf(stderr, "LAPACK error: dbdsqr failed to converge in sam_absorsvd();\n%d %s", info,
        "superdiagonals of an intermediate bidiagonal form did not converge to zero\n");
    memset(R, 0, 9*sizeof(double));
    if(t) memset(t, 0, 3*sizeof(double));

    return 1;
  }
#endif

  /* currently no collinearity check for the p, q. They are collinear
   * when two of the singular values are equal
   */

  /* compute R as V * U^t. Remember that Vt & U are in column major */
  R[0]=Vt[0][0]*U[0][0] + Vt[0][1]*U[1][0] + Vt[0][2]*U[2][0];
  R[1]=Vt[0][0]*U[0][1] + Vt[0][1]*U[1][1] + Vt[0][2]*U[2][1];
  R[2]=Vt[0][0]*U[0][2] + Vt[0][1]*U[1][2] + Vt[0][2]*U[2][2];

  R[3]=Vt[1][0]*U[0][0] + Vt[1][1]*U[1][0] + Vt[1][2]*U[2][0];
  R[4]=Vt[1][0]*U[0][1] + Vt[1][1]*U[1][1] + Vt[1][2]*U[2][1];
  R[5]=Vt[1][0]*U[0][2] + Vt[1][1]*U[1][2] + Vt[1][2]*U[2][2];

  R[6]=Vt[2][0]*U[0][0] + Vt[2][1]*U[1][0] + Vt[2][2]*U[2][0];
  R[7]=Vt[2][0]*U[0][1] + Vt[2][1]*U[1][1] + Vt[2][2]*U[2][1];
  R[8]=Vt[2][0]*U[0][2] + Vt[2][1]*U[1][2] + Vt[2][2]*U[2][2];

  if(sam_det3x3(R)<0){ // R is a reflection, see p. 699 in Arun et al.
    if(S[2]>S[0]*1E-03){ // case b): smallest singular value (S[2]) is nonzero
      memset(R, 0, 9*sizeof(double));
      if(t) memset(t, 0, 3*sizeof(double));

      return 2;
    }

    /* case a): change the sign of V's 3rd column and recompute R */
    Vt[0][2]=-Vt[0][2]; Vt[1][2]=-Vt[1][2]; Vt[2][2]=-Vt[2][2];
    R[0]=Vt[0][0]*U[0][0] + Vt[0][1]*U[1][0] + Vt[0][2]*U[2][0];
    R[1]=Vt[0][0]*U[0][1] + Vt[0][1]*U[1][1] + Vt[0][2]*U[2][1];
    R[2]=Vt[0][0]*U[0][2] + Vt[0][1]*U[1][2] + Vt[0][2]*U[2][2];

    R[3]=Vt[1][0]*U[0][0] + Vt[1][1]*U[1][0] + Vt[1][2]*U[2][0];
    R[4]=Vt[1][0]*U[0][1] + Vt[1][1]*U[1][1] + Vt[1][2]*U[2][1];
    R[5]=Vt[1][0]*U[0][2] + Vt[1][1]*U[1][2] + Vt[1][2]*U[2][2];

    R[6]=Vt[2][0]*U[0][0] + Vt[2][1]*U[1][0] + Vt[2][2]*U[2][0];
    R[7]=Vt[2][0]*U[0][1] + Vt[2][1]*U[1][1] + Vt[2][2]*U[2][1];
    R[8]=Vt[2][0]*U[0][2] + Vt[2][1]*U[1][2] + Vt[2][2]*U[2][2];
  }

  if(!t) return 0;

  if(sc!=NULL){
    /* t = qc - R sc*pc */
    t[0]=qc[0] - scale*(R[0]*pc[0] + R[1]*pc[1] + R[2]*pc[2]);
    t[1]=qc[1] - scale*(R[3]*pc[0] + R[4]*pc[1] + R[5]*pc[2]);
    t[2]=qc[2] - scale*(R[6]*pc[0] + R[7]*pc[1] + R[8]*pc[2]);
  }
  else{
    /* t = qc - R *pc */
    t[0]=qc[0] - (R[0]*pc[0] + R[1]*pc[1] + R[2]*pc[2]);
    t[1]=qc[1] - (R[3]*pc[0] + R[4]*pc[1] + R[5]*pc[2]);
    t[2]=qc[2] - (R[6]*pc[0] + R[7]*pc[1] + R[8]*pc[2]);
  }

  return 0;
}

/*********************************** Robust estimation of absolute orientation ***************************************/
#include "lqs.h"
#include "ransac.h"
#include "prosac.h"


#define USE_LQS_FIT    0 // use LQS (LMedS) if 1
#define USE_RANSAC_FIT 1 // use RANSAC if 1
#define USE_PROSAC_FIT 0 // use PROSAC if 1

#if USE_LQS_FIT + USE_RANSAC_FIT + USE_PROSAC_FIT != 1
#error Exactly one of the USE_XXX_FIT macros should be defined as 1!
#endif


/* variables used by various estimation routines */
struct AbsOrData {
  double (*pts0)[3], (*pts1)[3];
  int *inliersidx, numInliers;
};


/* estimate absolute orientation s.t. P1=sc*R*P0+t, with P0, P1 specified by ptsidx */
static int sam_estabsorq_scale(double *Rts, int npts, int *ptsidx, void *adata)
{
int n;
struct AbsOrData *dat=(struct AbsOrData *)adata;
double (*pts0)[3]=dat->pts0, (*pts1)[3]=dat->pts1;

  n=sam_absorq(pts0, pts1, ptsidx, npts, Rts, Rts+9, Rts+9+3);

  return n==0;
}

/* as above without scale: P1=R*P0+t */
static int sam_estabsorq_noscale(double *Rts, int npts, int *ptsidx, void *adata)
{
int n;
struct AbsOrData *dat=(struct AbsOrData *)adata;
double (*pts0)[3]=dat->pts0, (*pts1)[3]=dat->pts1;

  n=sam_absorq(pts0, pts1, ptsidx, npts, Rts, Rts+9, NULL);

  return n==0;
}

/* compute the geometric residuals corresponding to Rts as the (squared) distance between actual
 * and predicted points: pts1 = R sc*pts0 + t
 */
#define _SQR(x) ((x)*(x))
static void sam_absorResidualsGeom_scale(double *Rts, int numres, void *adata, double *resid)
{
register int i;
double *R, *t, sc, X, Y, Z, Xp, Yp, Zp;
struct AbsOrData *dat=(struct AbsOrData *)adata;
double (*pts0)[3]=dat->pts0, (*pts1)[3]=dat->pts1;

  R=Rts; t=R+9; sc=t[3];
  for(i=0; i<numres; ++i){
    X=pts0[i][0]; Y=pts0[i][1]; Z=pts0[i][2];
    /* transform point; inner parentheses below break dependency chains */
    Xp=sc*((R[0]*X + R[1]*Y) + R[2]*Z) + t[0];
    Yp=sc*((R[3]*X + R[4]*Y) + R[5]*Z) + t[1];
    Zp=sc*((R[6]*X + R[7]*Y) + R[8]*Z) + t[2];

    Xp-=pts1[i][0]; Yp-=pts1[i][1]; Zp-=pts1[i][2];
    resid[i]=_SQR(Xp) + _SQR(Yp) + _SQR(Zp);
  }
}

/* as above without scale: pts1 = R*pts0 + t */
static void sam_absorResidualsGeom_noscale(double *Rts, int numres, void *adata, double *resid)
{
register int i;
double *R, *t, X, Y, Z, Xp, Yp, Zp;
struct AbsOrData *dat=(struct AbsOrData *)adata;
double (*pts0)[3]=dat->pts0, (*pts1)[3]=dat->pts1;

  R=Rts; t=R+9;
  for(i=0; i<numres; ++i){
    X=pts0[i][0]; Y=pts0[i][1]; Z=pts0[i][2];
    /* transform point; parentheses below break dependency chains */
    Xp=(R[0]*X + R[1]*Y) + (R[2]*Z + t[0]);
    Yp=(R[3]*X + R[4]*Y) + (R[5]*Z + t[1]);
    Zp=(R[6]*X + R[7]*Y) + (R[8]*Z + t[2]);

    Xp-=pts1[i][0]; Yp-=pts1[i][1]; Zp-=pts1[i][2];
    resid[i]=_SQR(Xp) + _SQR(Yp) + _SQR(Zp);
  }
}
#undef _SQR

/* Robust absolute orientation estimation from "nmatches" matched 3D point pairs, possibly
 * including outliers. "pts0", "pts1" contain the matched 3D-3D point coordinates, "samplesz"
 * is the cardinality of the sets to be drawn during random sampling (>=3); this allows for
 * non-minimal sampling. "inlPcent" is the expected percentage of inliers (>=0.5), "outlThresh"
 * is the distance threshold for determining the outliers (relevant to RANSAC/PROSAC only),
 * "R, t, scale" contain the estimated parameters upon return, idxOutliers" points to sufficiently
 * large memory which upon return is set to the indices of the detected outlying points
 * (pass NULL if don't care), "nbOutliers" contains the number of outliers, "verbose" specifies
 * the verbosity level
 * If scale has been set to NULL by the caller, then the scale is assumed fixed and equal to 1.0
 *
 * Returns 1 in case of error, 0 if successfull
 *
 * Currently computes the orientation of each random sample using the quaternion method,
 * the SVD-based method could also be used.
 */
int sam_absorqRob(double (*pts0)[3], double (*pts1)[3], int nmatches, int samplesz, double inlPcent, double outlThresh, 
                          double R[9], double t[3], double *scale, int *idxOutliers, int *nbOutliers, int verbose)
{
register int i, j;
double gate=2.0, premResid=-1.0;
int *outliersMap, ret, **sets=NULL, nbSets=0, nparams;
struct AbsOrData dat;
const int isSqr=1, maxNbSol=1;
double Rts[9+3+1]; // layout is R (3x3), t (1x3), scale (1x1)
int  (*estimator)(double *Rts, int npts, int *ptsidx, void *adata);
void (*residuals)(double *Rts, int numres, void *adata, double *resid);

  if(nmatches<3) return 1;  // too few matches

  if(samplesz<3) samplesz=3; // at least 3 matches for each sample

  if(samplesz>nmatches) samplesz=nmatches; // use all available matches

  if(scale==NULL){
    estimator=sam_estabsorq_noscale;
    residuals=sam_absorResidualsGeom_noscale;
    nparams=9+3;
  }
  else{
    estimator=sam_estabsorq_scale;
    residuals=sam_absorResidualsGeom_scale;
    nparams=9+3+1;
  }

  dat.pts0=pts0; dat.pts1=pts1;
  dat.inliersidx=NULL;

  if(!(outliersMap=(int *)malloc(nmatches*sizeof(int)))){
    fprintf(stderr, "Error: not enough memory for 'outliersMap' in sam_absorqRob()\n");
    exit(1);
  }
  verbose=verbose>1;

#if USE_LQS_FIT==1
  j=lqsfit(nmatches, samplesz, sets, nbSets, residuals, estimator,
            isSqr, verbose, maxNbSol, gate, premResid, nparams, inlPcent, (void *)&dat,
            Rts, NULL, outliersMap, nbOutliers, &outlThresh);
#elif (USE_RANSAC_FIT==1) || (USE_PROSAC_FIT==1)
  gate=premResid=0; /* -Wall */

#if USE_RANSAC_FIT==1
  j=ransacfit(nmatches, samplesz, sets, nbSets, residuals, estimator,
            isSqr, verbose, maxNbSol, outlThresh, 0, nparams, inlPcent, (void *)&dat,
            Rts, NULL, outliersMap, nbOutliers);
#else
  j=prosacfit(nmatches, samplesz, residuals, estimator,
            isSqr, verbose, maxNbSol, outlThresh, 0, nparams, inlPcent, (void *)&dat,
            Rts, NULL, outliersMap, nbOutliers);
#endif
#endif /* USE_LQS_FIT */

  if(verbose){
    fprintf(stderr, "Outlier threshold: %g\n", outlThresh);
    fprintf(stderr, "sam_absorqRob(): robust fit returned %d, %d outliers [out of %d]\n", j, *nbOutliers, nmatches);
  }

  if(sets) lqs_freesets(sets);

  dat.numInliers=nmatches - *nbOutliers;
  if(j!=0){
    dat.inliersidx=(int *)malloc(dat.numInliers*sizeof(int));
    if(!dat.inliersidx){
      fprintf(stderr, "Error: not enough memory for 'dat.inliersidx' in sam_absorqRob()\n");
      exit(1);
    }

    for(i=j=0; i<nmatches; ++i)
      if(!outliersMap[i]) dat.inliersidx[j++]=i;

    /* LS estimation on inliers */
    estimator(Rts, dat.numInliers, dat.inliersidx, (void *)&dat);

    /* expose outliers */
    if(idxOutliers!=NULL)
      for(i=j=0; i<nmatches; ++i)
        if(outliersMap[i]) idxOutliers[j++]=i;

#if 0
    if(verbose){
      fputs("Outliers: ", stderr);
      for(i=j=0; i<nmatches; ++i)
        if(outliersMap[i]) fprintf(stderr, "%d ", i);
      fputc('\n', stderr);
    }
#endif

    ret=0;

#if 0
    /* include the following code fragment to print the matching 3D point pairs found to be inlying */
    for(i=0; i<dat.numInliers; ++i){
      printf("%.4lf %.4lf %.4lf   %.4lf %.4lf %.4lf\n", pts0[dat.inliersidx[i]][0], pts0[dat.inliersidx[i]][1], pts0[dat.inliersidx[i]][2],
                                          pts1[dat.inliersidx[i]][0],  pts1[dat.inliersidx[i]][1]], pts1[dat.inliersidx[i]][2]);
    }
#endif

  }
  else{ /* robust fit failed */
    memset(Rts, 0, nparams*sizeof(double));
    *nbOutliers=nmatches;
    dat.numInliers=0;
    ret=1;
  }

  memcpy(R, Rts,   9*sizeof(double));
  if(t!=NULL)
    memcpy(t, Rts+9, 3*sizeof(double));
  if(scale!=NULL)
    *scale=Rts[12];

  if(dat.inliersidx) free(dat.inliersidx);
  free(outliersMap);

  return ret;
}

/* compute the average distance between two point sets presumably related as pts1 = R sc*pts0 + t */
double sam_absordist(double (*pts0)[3], double (*pts1)[3], int *indx, int npts, double R[9], double t[3], double sc)
{
register int i;
double X, Y, Z, *pt0, *pt1, sum=0.0;

  if(!indx){
    for(i=0; i<npts; ++i){
      pt0=pts0[i];
      pt1=pts1[i];

      /* transform point */
      X=sc*(R[0]*pt0[0] + R[1]*pt0[1] + R[2]*pt0[2]) + t[0];
      Y=sc*(R[3]*pt0[0] + R[4]*pt0[1] + R[5]*pt0[2]) + t[1];
      Z=sc*(R[6]*pt0[0] + R[7]*pt0[1] + R[8]*pt0[2]) + t[2];

      X-=pt1[0];
      Y-=pt1[1];
      Z-=pt1[2];

      sum+=sqrt(X*X + Y*Y + Z*Z);
    }
  }
  else{
    for(i=0; i<npts; ++i){
      pt0=pts0[indx[i]];
      pt1=pts1[indx[i]];

      /* transform point */
      X=sc*(R[0]*pt0[0] + R[1]*pt0[1] + R[2]*pt0[2]) + t[0];
      Y=sc*(R[3]*pt0[0] + R[4]*pt0[1] + R[5]*pt0[2]) + t[1];
      Z=sc*(R[6]*pt0[0] + R[7]*pt0[1] + R[8]*pt0[2]) + t[2];

      X-=pt1[0];
      Y-=pt1[1];
      Z-=pt1[2];

      sum+=sqrt(X*X + Y*Y + Z*Z);
    }
  }

  return sum/(double)npts;
}

/*********************************** Robust estimation of absolute orientation ***************************************/

#if 0
#define N 25
main()
{
register int i;
double R[9], t[3], sc;
double pts0[N][3]={
  {68.1335, 66.5823, 13.4718},
  {2.2493, 26.2199, 11.6515},
  {6.9318, 85.2930, 18.0331},
  {3.2419, 73.3926, 53.6517},
  {27.6030, 36.8458, 1.2886},
  {88.9206, 86.6021, 25.4247},
  {56.9481, 15.9265, 59.4364},
  {33.1100, 65.8613, 86.3634},
  {56.7623, 98.0481, 79.1832},
  {15.2594, 83.3027, 19.1863},
  {63.8987, 66.9000, 77.2088},
  {37.9818, 44.1585, 48.3060},
  {60.8106, 17.5996, 0.2026},
  {79.0224, 51.3609, 21.3229},
  {10.3450, 15.7337, 40.7515},
  {40.7757, 5.2693, 94.1815},
  {14.9972, 38.4374, 31.1059},
  {16.8534, 89.6648, 32.2724},
  {73.3996, 41.0904, 39.9794},
  {50.5522, 16.9306, 52.4745},
  {64.1203, 1.6197, 83.6852},
  {80.3462, 69.7785, 46.1888},
  {8.2613, 82.0717, 19.3020},
  {44.5355, 1.2958, 30.8742},
  {87.5351, 83.5259, 33.3095},
};

double pts1[N][3]={
  {46.5829, -44.7961, -19.1256},
  {1.6247, -15.4200, -12.5944},
  {3.6873, -53.7281, -28.9906},
  {3.5008, -38.2667, -50.4061},
  {18.4135, -25.7363, -6.7094},
  {61.2346, -56.5751, -30.2925},
  {42.8038, -1.0098, -39.6772},
  {26.4218, -27.7549, -69.2046},
  {41.6357, -51.7312, -70.0347},
  {9.6122, -52.5170, -28.9465},
  {47.3246, -31.6549, -61.8592},
  {28.1848, -21.3432, -39.0732},
  {42.0111, -14.5332, -0.3783},
  {55.0345, -33.4792, -20.6524},
  {9.2374, -2.7528, -29.4027},
  {33.8321, 13.9744, -61.3643},
  {11.3159, -20.0980, -27.5080},
  {11.3142, -54.1268, -38.9214},
  {52.4719, -22.5286, -31.1997},
  {37.9142, -2.8457, -35.5529},
  {49.5926, 13.2441, -52.4973},
  {56.9114, -40.6892, -41.0124},
  {4.7735, -51.3726, -29.0984},
  {32.8815, 3.3822, -18.1741},
  {60.8087, -52.8333, -34.9677},
};

int outlmap[N], noutl;

  /* absolute orientation with scale */
  printf("Explicitly estimating scale\n\n");
  sam_absorq(pts0, pts1, NULL, N, R, t, &sc);

  printf("%g %g %g\n", R[0], R[1], R[2]);
  printf("%g %g %g\n", R[3], R[4], R[5]);
  printf("%g %g %g\n", R[6], R[7], R[8]);
  printf("\n%g %g %g\n", t[0], t[1], t[2]);
  printf("\n%g\n", sc);

  sam_absorqRob(pts0, pts1, N, 0.8, 0.1, R, t, &sc, outlmap, &noutl, 0);
  printf("\nRobust absolute orientation (%d outliers)\n", noutl);
  printf("%g %g %g\n", R[0], R[1], R[2]);
  printf("%g %g %g\n", R[3], R[4], R[5]);
  printf("%g %g %g\n", R[6], R[7], R[8]);
  printf("\n%g %g %g\n", t[0], t[1], t[2]);
  printf("\n%g\n", sc);

  printf("===============================================================\n");
  printf("Not estimating scale\n");
  /* absolute orientation without scale */

  /* undo the effect of scale on pts1 (0.7 is the ground truth scale) */
  for(i=0; i<N; ++i){
    pts1[i][0]/=0.7;
    pts1[i][1]/=0.7;
    pts1[i][2]/=0.7;
  }

  //sam_absorqRob(pts0, pts1, N, 0.8, 0.1, R, t, NULL, outlmap, &noutl, 0);
  sam_absorq(pts0, pts1, NULL, N, R, t, NULL);
  printf("\nRobust absolute orientation (%d outliers)\n", noutl);
  printf("%g %g %g\n", R[0], R[1], R[2]);
  printf("%g %g %g\n", R[3], R[4], R[5]);
  printf("%g %g %g\n", R[6], R[7], R[8]);
  printf("\n%g %g %g\n", t[0], t[1], t[2]);
  printf("\n[%g %g %g]\n\n", t[0]*0.7, t[1]*0.7, t[2]*0.7);
  /* t above equals ts*0.7 where ts the translation for the scaled case */
}
#endif
