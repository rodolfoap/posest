/////////////////////////////////////////////////////////////////////////////////
// 
//  Non-linear calibrated camera pose estimation from 3D - 2D correspondences
//  Copyright (C) 2011-13  Manolis Lourakis (lourakis **at** ics.forth.gr)
//  Institute of Computer Science, Foundation for Research & Technology - Hellas
//  Heraklion, Crete, Greece.
//
/////////////////////////////////////////////////////////////////////////////////

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <string.h>
#include <math.h>
#include <float.h>

#include "sam.h"

#include "compiler.h"
#include "util.h"
#include "posest.h"
#include "p3p.h"
#include "planep4p.h"
//#include "epnp.h"
#include "p4pf.h"
#include "poseproj.h"

#include "lqs.h"
#include "ransac.h"
#include "prosac.h"

#include <levmar.h>
#include <mlsl.h>

#define USE_ROBUST_LM       0 // enable robustified L-M?
#define USE_INPLACE_REFN    1 // enable in-place parameterization for refinement

#define USE_LQS_FIT    0 // use LQS (LMedS) if 1
#define USE_RANSAC_FIT 1 // use RANSAC if 1
#define USE_MLESAC_FIT 0 // use MLESAC if 1
#define USE_PROSAC_FIT 0 // use PROSAC if 1; ensure that sorting of matches is on in matchSIFT.c

#if USE_LQS_FIT + USE_RANSAC_FIT + USE_MLESAC_FIT + USE_PROSAC_FIT != 1
#error Exactly one of the USE_XXX_FIT macros should be defined as 1!
#endif

#define RANSAC_OUTL_THRESH	4.0 // relevant to RANSAC/PROSAC only

//#define USE_BUCKETS // CHECKME


/* minimal number of 2D-3D matches, selects the PNP algorithm to be used */
//#define NUM_PNPMATCHES    3 // P3P
#define NUM_PNPMATCHES    4 // P4P, 4th point used for verification of P3P results
//#define NUM_PNPMATCHES    6 // EPnP

/* minimal number of 2D-3D matches for the P4Pf algorithm */
#define NUM_P4PFMATCHES   4

#define MIN_TRIANG_AREA   200.0 // min allowable area for image points in P3P (pixels)

#define SQR(x) ((x)*(x))

/***** robust nonlinear estimation of rotation and translation, intrinsics assumed known *****/

/* variables used by various estimation routines */
struct RTdata {
  double *K; // intrinsics
  struct p3p_calib_params cal; // intrinsics as required by p3p
  double (*pts2D)[2], (*pts3D)[3];
  int *inliersidx, numInliers;
};


/* compute the rotation vector corresponding to a rotation matrix; see A8 in Horn's paper
 * Similar to sam_rotmat2vec() with the addition of a return code.
 *
 * returns 0 if successful, 1 otherwise
 */
#define _CLAMP(a, b, x) ( ((x)<=(a))? (a) : (((x)<=(b))? (x) : (b)) )
static int rotmat2rodr(double R[9], double rv[3])
{
register int i;
int maxpos=-1; /* -Wall */
double q[4], tmp[4], mag, s, th;

  /* convert to quaternion */
	/* find the maximum of the 4 quantities */
	tmp[0]=1.0 + R[0] + R[4] + R[8];
	tmp[1]=1.0 + R[0] - R[4] - R[8];
	tmp[2]=1.0 - R[0] + R[4] - R[8];
	tmp[3]=1.0 - R[0] - R[4] + R[8];

	for(i=0, mag=-1.0; i<4; i++)
		if(tmp[i]>mag){
			mag=tmp[i];
			maxpos=i;
		}

	switch(maxpos){
	case 0:
		q[0]=sqrt(tmp[0])*0.5;
		q[1]=(R[7] - R[5])/(4.0*q[0]);
		q[2]=(R[2] - R[6])/(4.0*q[0]);
		q[3]=(R[3] - R[1])/(4.0*q[0]);
		break;
	case 1:
		q[1]=sqrt(tmp[1])*0.5;
		q[0]=(R[7] - R[5])/(4.0*q[1]);
		q[2]=(R[3] + R[1])/(4.0*q[1]);
		q[3]=(R[2] + R[6])/(4.0*q[1]);
		break;
	case 2:
		q[2]=sqrt(tmp[2])*0.5;
		q[0]=(R[2] - R[6])/(4.0*q[2]);
		q[1]=(R[3] + R[1])/(4.0*q[2]);
		q[3]=(R[7] + R[5])/(4.0*q[2]);
		break;
	case 3:
		q[3]=sqrt(tmp[3])*0.5;
		q[0]=(R[3] - R[1])/(4.0*q[3]);
		q[1]=(R[2] + R[6])/(4.0*q[3]);
		q[2]=(R[7] + R[5])/(4.0*q[3]);
		break;
	default: /* should not happen */
		fprintf(stderr, "Internal error in rotmat2rodr()\nR:\n");
    fprintf(stderr, "%g %g %g\n", R[0], R[1], R[2]);
    fprintf(stderr, "%g %g %g\n", R[3], R[4], R[5]);
    fprintf(stderr, "%g %g %g\n", R[6], R[7], R[8]);
    return 1;
		//exit(1);
	}

	/* enforce unit length */
	mag=q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + q[3]*q[3];

	if(mag!=1.0){
	  mag=1.0/sqrt(mag);
	  q[0]*=mag; q[1]*=mag; q[2]*=mag; q[3]*=mag;
  }

  th=acos(_CLAMP(-1.0, 1.0, q[0]));
  s=sin(th);
  th=2.0*th;
  if(fabs(s)>1E-08){
    th/=s;
    rv[0]=q[1]*th;
    rv[1]=q[2]*th;
    rv[2]=q[3]*th;
  }
  else{ // s close to zero, axis direction unimportant
    rv[0]=th;
    rv[1]=rv[2]=0.0;
  }

  return 0;
}
#undef _CLAMP


/* compute the rotation matrix corresponding to a rotation vector.
 * Code generated by maple's codegen package and minimal editing (rodrigues.mpl)
 */
static void rvec2rotmat(double r[3], double R[9])
{
double t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t14, t16, t17, t18, t20, t22, t24, t27, t31, t33;

  t1 = r[0]*r[0];
  t2 = r[1]*r[1];
  t3 = r[2]*r[2];
  t4 = t1+t2+t3;

  if(t4<=1E-14){ // zero, R=I
    R[0]=R[4]=R[8]=1.0;
    R[1]=R[2]=R[3]=R[5]=R[6]=R[7]=0.0;
    return;
  }

  t5 = sqrt(t4);
#ifdef _MSC_VER
  __asm {
    fld QWORD PTR [t5]
    fsincos
    fstp QWORD PTR [t6]  ; cosine
    fstp QWORD PTR [t14] ; sine
  }
#else
  SINCOS(t5, &t14, &t6);
  //t6 = cos(t5);
  //t14 = sin(t5);
#endif
  t7 = 1.0-t6;
  t8 = 1/t4;
  t9 = t8*t3;
  t10 = t8*t2;
  t16 = t14/t5;
  t17 = t16*r[2];
  t18 = t7*t8;
  t20 = t18*r[1]*r[0];
  t22 = t16*r[1];
  t24 = t18*r[2]*r[0];
  t27 = t8*t1;
  t31 = t16*r[0];
  t33 = t18*r[2]*r[1];
  R[0] = 1.0+t7*(-t9-t10);
  R[1] = -t17+t20;
  R[2] = t22+t24;
  R[3] = t17+t20;
  R[4] = 1.0+t7*(-t9-t27);
  R[5] = -t31+t33;
  R[6] = -t22+t24;
  R[7] = t31+t33;
  R[8] = 1.0+t7*(-t10-t27);
}

/* P = K [R t] */
void posest_PfromKRt(double P[NUM_PPARAMS], double K[9], double rt[NUM_RTPARAMS])
{
register int j;
double R[9], *t=rt+3;

  rvec2rotmat(rt, R);

  /* compute the j-th row of K*[R t] */
  for(j=0; j<3; ++j){
    P[j]=K[0]*R[j] + K[1]*R[3+j] + K[2]*R[6+j];
    P[3]=K[0]*t[0] + K[1]*t[1]   + K[2]*t[2];

    /* K[3] assumed zero */
    P[4+j]=K[4]*R[3+j] + K[5]*R[6+j];
    P[7]=  K[4]*t[1]   + K[5]*t[2];

    /* K[6], K[7] assumed zero */
    P[8+j]=K[8]*R[6+j];
    P[11]= K[8]*t[2];
  }
}

/* triangle area, see http://mathworld.wolfram.com/TriangleArea.html */
#define _TRIANGLE_AREA(pt1, pt2, pt3)\
    fabs(0.5*(-(pt2)[0]*(pt1)[1] + (pt3)[0]*(pt1)[1] +\
               (pt1)[0]*(pt2)[1] - (pt3)[0]*(pt2)[1] -\
               (pt1)[0]*(pt3)[1] + (pt2)[0]*(pt3)[1]))

#define _CROSSPROD(v, x, y){ (v)[0]=(x)[1]*(y)[2] - (x)[2]*(y)[1]; (v)[1]=(x)[2]*(y)[0] - (x)[0]*(y)[2]; (v)[2]=(x)[0]*(y)[1] - (x)[1]*(y)[0]; }
#define _SAME_POINT(p1, p2) ( ( (p1)[0]==(p2)[0] ) && ( (p1)[1]==(p2)[1] ) )
 
/* estimate "point" pose P=K[R t] s.t. m=P*M, with m, M specified by ptsidx */
static int estP3PPose(double *rt, int npts, int *ptsidx, void *adata)
{
int nposes;
struct RTdata *dat=(struct RTdata *)adata;
double (*pts2D)[2]=dat->pts2D, (*pts3D)[3]=dat->pts3D;
double *m0, *m1, *m2, *M0, *M1, *M2;
double m[NUM_PNPMATCHES][2], M[NUM_PNPMATCHES][3];

  //if(npts<NUM_PNPMATCHES) return 0; // not enough points

  m0=pts2D[ptsidx[0]]; M0=pts3D[ptsidx[0]];
  m1=pts2D[ptsidx[1]]; M1=pts3D[ptsidx[1]];
  m2=pts2D[ptsidx[2]]; M2=pts3D[ptsidx[2]];

  /* area check; note that this also enforces non-collinearity */
#if NUM_PNPMATCHES<=4
  if(_TRIANGLE_AREA(m0, m1, m2)<MIN_TRIANG_AREA) return 0; // points not sufficiently far apart
#endif

#if 0 // next check only applies to non 1-1 matches
  if(_SAME_POINT(m0, m1) || _SAME_POINT(m0, m2) || _SAME_POINT(m1, m2)) return 0; // not unique points
#endif

  m[0][0]=m0[0]; m[0][1]=m0[1];
  m[1][0]=m1[0]; m[1][1]=m1[1];
  m[2][0]=m2[0]; m[2][1]=m2[1];

  M[0][0]=M0[0]; M[0][1]=M0[1]; M[0][2]=M0[2];
  M[1][0]=M1[0]; M[1][1]=M1[1]; M[1][2]=M1[2];
  M[2][0]=M2[0]; M[2][1]=M2[1]; M[2][2]=M2[2];

#if NUM_PNPMATCHES==3 // up to 4 solutions
  {
    double R[4][3][3], t[4][3], *prt;
    register int i, j;

    /* solve P3P */
    /* only the first 3 lines of m, M used in the following */
    nposes=p3p_solve3(&(dat->cal), m, M, R, t); // Grunert's solution
    //nposes=p3p_Kneip(&(dat->cal), m, M, R, t); // Kneip's solution
    for(i=j=0; i<nposes; ++i){
      prt=rt+j*NUM_RTPARAMS;
      if(!rotmat2rodr((double *)R[i], prt)){
        prt[3]=t[i][0];
        prt[4]=t[i][1];
        prt[5]=t[i][2];
        ++j;
      }
    }
    nposes=j;
  }
#elif NUM_PNPMATCHES==4 // P4P, single solution
  {
    double *rv, *t, R[3][3];
    double *m3, *M3;
    int ra, rb;
    double u[3], v[3], plnorm[3];

    u[0]=M1[0]-M0[0]; u[1]=M1[1]-M0[1]; u[2]=M1[2]-M0[2]; // M1-M0
    v[0]=M2[0]-M0[0]; v[1]=M2[1]-M0[1]; v[2]=M2[2]-M0[2]; // M2-M0
    _CROSSPROD(plnorm, u, v); // normal to the plane of M0, M1, M2

    rv=rt; t=rt+3;
    m3=pts2D[ptsidx[3]]; M3=pts3D[ptsidx[3]];

    /* 4th line of m, M */
    m[3][0]=m3[0]; m[3][1]=m3[1];
    M[3][0]=M3[0]; M[3][1]=M3[1]; M[3][2]=M3[2];

    /* solve P4P */
# if 1
    ra=p3p_solve4_2Derr(&(dat->cal), m, M, R, t);
    rb=p3p_solve4_3Derr(&(dat->cal), m, M, plnorm, R, t);
    nposes=(ra && ra==rb);

    /*
    // solve with Ansar & Daniilidis
    for(i=0; i<4; ++i){
      m[i][0] = dat->cal.inv_fx * m[i][0] - dat->cal.s_fxfy * m[i][1] + dat->cal.scy_cxfy_fxfy;
      m[i][1] = dat->cal.inv_fy * m[i][1] - dat->cal.cy_fy;
    }
    ra=ad_estPose(m, M, 4, R[0], t);
    nposes=(ra==0);
    */

# else // differentiate between coplanar/non-coplanar point quadruples
    {
    double mag1, th;
    const double tol=(7.0/180.0)*M_PI; // tolerance for an angle to be considered right

    /* normalize plane normal and M3-M0 */
    mag1=plnorm[0]*plnorm[0] + plnorm[1]*plnorm[1] + plnorm[2]*plnorm[2];
    if(mag1< 1E-15) return 0; // points are collinear

    mag1=1.0/sqrt(mag1);
    plnorm[0]*=mag1; plnorm[1]*=mag1; plnorm[2]*=mag1;

    u[0]=M3[0]-M0[0]; u[1]=M3[1]-M0[1]; u[2]=M3[2]-M0[2];
    mag1=1.0/sqrt(u[0]*u[0] + u[1]*u[1] + u[2]*u[2]);
    u[0]*=mag1; u[1]*=mag1; u[2]*=mag1;

    /* angle between plane normal and u */
    th=acos(plnorm[0]*u[0] + plnorm[1]*u[1] + plnorm[2]*u[2]);

    if(fabs(M_PI_2-th)<=tol){ // th close to 90 degrees
      //nposes=coplanarP4P_FB(&(dat->cal), m, M, R, t);
      nposes=coplanarP4P_Zhang(&(dat->cal), m, M, R, t);
    }else{
      ra=p3p_solve4_2Derr(&(dat->cal), m, M, R, t);
      rb=p3p_solve4_3Derr(&(dat->cal), m, M, plnorm, R, t);
      nposes=(ra && ra==rb);
    }
    }
# endif

    if(nposes)
      nposes=!(rotmat2rodr((double *)R, rv));
  }
#else // NUM_PNPMATCHES>4, single solution with EPnP
  {
    double *rv, *t, R[9];
    register int i;

    rv=rt; t=rt+3;
    for(i=0; i<NUM_PNPMATCHES; ++i){
      m0=pts2D[ptsidx[i]]; M0=pts3D[ptsidx[i]];

      /* i-th line of m, M */
      m[i][0]=m0[0]; m[i][1]=m0[1];
      M[i][0]=M0[0]; M[i][1]=M0[1]; M[i][2]=M0[2];

      /* remove effect of intrinsics */
      m[i][0] = dat->cal.inv_fx * m[i][0] - dat->cal.s_fxfy * m[i][1] + dat->cal.scy_cxfy_fxfy;
      m[i][1] = dat->cal.inv_fy * m[i][1] - dat->cal.cy_fy;
    }
    i=epnp_solve(m, M, NUM_PNPMATCHES, R, t);
    nposes=(i==0);
    if(nposes)
      nposes=!(rotmat2rodr((double *)R, rv));
  }
#endif

  return nposes;
}

/* compute the geometric residuals corresponding to pose as the (squared) distance between actual and predicted point */
static void poseRTResidualsGeom(double rt[NUM_RTPARAMS], int numres, void *adata, double *resid)
{
register int i;
double P[NUM_PPARAMS], X, Y, Z, s, ppt[2];
struct RTdata *dat=(struct RTdata *)adata;
double (*pts2D)[2]=dat->pts2D, (*pts3D)[3]=dat->pts3D;

  /* P=K[R t] */
  posest_PfromKRt(P, dat->K, rt);

  for(i=0; i<numres; ++i){
    /* project 3D point */
    X=pts3D[i][0]; Y=pts3D[i][1]; Z=pts3D[i][2];
     s=1.0/(P[8]*X + P[9]*Y + P[10]*Z + P[11]);
    ppt[0]=(P[0]*X + P[1]*Y + P[2]*Z  + P[3])*s;
    ppt[1]=(P[4]*X + P[5]*Y + P[6]*Z  + P[7])*s;

    ppt[0]-=pts2D[i][0]; ppt[1]-=pts2D[i][1];
    resid[i]=(SQR(ppt[0]) + SQR(ppt[1]));
  }
}

/* reprojection error and Jacobian */
static void ptsProjRT(double *rt, double *x, int m, int n, void *adata)
{
struct RTdata *dat=(struct RTdata *)adata;
int ninl=dat->numInliers, *inlidx=dat->inliersidx;
double *K=dat->K, (*pts3D)[3]=dat->pts3D;
register int i;

#if 1 /* fast version based on computing and reusing P */
double P[NUM_PPARAMS], X, Y, Z, s, *ppt;
int j;

  /* P=K[R t] */
  posest_PfromKRt(P, K, rt);
  for(i=0; i<ninl; ++i){
    j=inlidx[i];
    ppt=x+(i<<1); // 2*i

    X=pts3D[j][0]; Y=pts3D[j][1]; Z=pts3D[j][2];
    // parentheses below break dependency chains
     s=1.0/((P[8]*X + P[9]*Y) + (P[10]*Z + P[11]));
    ppt[0]=((P[0]*X + P[1]*Y) + (P[2]*Z  + P[3]))*s;
    ppt[1]=((P[4]*X + P[5]*Y) + (P[6]*Z  + P[7]))*s;
  }
#else
  for(i=0; i<ninl; ++i){
    calc_poseProjRT(K, rt, pts3D[inlidx[i]], x+i*2);
  }
#endif
}

static void ptsProjRTJac(double *rt, double *jac, int m, int n, void *adata)
{
register int i;
struct RTdata *dat=(struct RTdata *)adata;
int ninl=dat->numInliers, *inlidx=dat->inliersidx;
double *K=dat->K, (*pts3D)[3]=dat->pts3D;
register double *jacrow;

  //memset(jac, 0, m*n*sizeof(double));

#if 1 /* fast version based on computing and reusing P with the chain rule */
  {
  double P[NUM_PPARAMS];
  double gradP[2*12], gradrt[12*6];
  register int j;

  posest_PfromKRt(P, K, rt);
  calc_posePRTJac(K, rt, (double (*)[6])gradrt); // d P / d rt

#if 0  // zero pattern
  for(i=0; i<12; ++i){
    for(j=0; j<6; ++j)
      if(gradrt[i*6+j]) printf("x ");
      else printf("0 ");
    printf("\n");
  }
  printf("\n\n\n");
#endif

  for(i=0, jacrow=jac; i<ninl; ++i, jacrow+=2*6){
    calc_poseProjPJac(P, pts3D[inlidx[i]], (double (*)[12])gradP); // d m / d P

    /* d m / d rt = d m / d P * d P / d rt 
     * unrolled multiplication jacrow=gradP*gradrt; parentheses are used to break dependency chains
     *
     * gradP is sparse: [x x x x 0 0 0 0 x x x x; 0 0 0 0 x x x x x x x x], hence we can exploit this
     * to avoid a few multiplications
     */
    //for(j=0; j<6; ++j)
    for(j=6; j-->0;  ){
      jacrow[0*6+j]=
      ((gradP[0*12+0]*gradrt[0*6+j] + gradP[0*12+1]*gradrt[1*6+j]) + (gradP[0*12+2] *gradrt[2*6+j] +  gradP[0*12+3] *gradrt[3*6+j])) +
      //((gradP[0*12+4]*gradrt[4*6+j] + gradP[0*12+5]*gradrt[5*6+j]) + (gradP[0*12+6] *gradrt[6*6+j] +  gradP[0*12+7] *gradrt[7*6+j])) +
      ((gradP[0*12+8]*gradrt[8*6+j] + gradP[0*12+9]*gradrt[9*6+j]) + (gradP[0*12+10]*gradrt[10*6+j] + gradP[0*12+11]*gradrt[11*6+j]));

      jacrow[1*6+j]=
      //((gradP[1*12+0]*gradrt[0*6+j] + gradP[1*12+1]*gradrt[1*6+j]) + (gradP[1*12+2] *gradrt[2*6+j] +  gradP[1*12+3] *gradrt[3*6+j])) +
      ((gradP[1*12+4]*gradrt[4*6+j] + gradP[1*12+5]*gradrt[5*6+j]) + (gradP[1*12+6] *gradrt[6*6+j] +  gradP[1*12+7] *gradrt[7*6+j])) +
      ((gradP[1*12+8]*gradrt[8*6+j] + gradP[1*12+9]*gradrt[9*6+j]) + (gradP[1*12+10]*gradrt[10*6+j] + gradP[1*12+11]*gradrt[11*6+j]));
    }
  }
  }
#else
  for(i=0, jacrow=jac; i<ninl; ++i, jacrow+=2*m){
    calc_poseProjRTJac(K, rt, pts3D[inlidx[i]], jacrow, jacrow+m);
  }
#endif

#if 0
  printf("\n\n================================\n");
  printf("\n%g %g %g %g %g %g\n", jacrow[0], jacrow[1], jacrow[2], jacrow[3], jacrow[4], jacrow[5]);
  printf("%g %g %g %g %g %g\n\n", jacrow[6], jacrow[7], jacrow[8], jacrow[9], jacrow[10], jacrow[11]);
#endif
}


/* nonlinear refinement of camera pose; based on minimizing reprojection error
 *
 * doMLSL is 1 if the MLSL scheme schould be employed, 0 otherwise
 * inpl is 1 if function is called by refinePoseRT_inplace(), 0 otherwise
 */
static int refinePoseRT(double *p, struct RTdata *data, int doMLSL, int inpl, int verbose)
{
register int i, j;
double opts[LM_OPTS_SZ], info[LM_INFO_SZ], *x;
int m, n; // # unknowns & # constraints
int ninl=data->numInliers;
void (*err)(double *p, double *hx, int m, int n, void *adata);
void (*jacerr)(double *p, double *j, int m, int n, void *adata);
int ret;

  opts[0]=LM_INIT_MU; opts[1]=1E-12; opts[2]=1E-12; opts[3]=1E-15;
  opts[4]=LM_DIFF_DELTA; // relevant only if the finite difference Jacobian version is used 

  m=NUM_RTPARAMS; n=2*ninl; // two measurements per point
  if((x=(double *)malloc(n*sizeof(double)))==NULL){
    fprintf(stderr, "Memory allocation request failed in refinePoseRT()\n");
    exit(1);
  }
  for(i=0; i<ninl; ++i){
    j=i<<1; // 2*i
    x[j]  =data->pts2D[data->inliersidx[i]][0];
    x[j+1]=data->pts2D[data->inliersidx[i]][1];
  }
  err=ptsProjRT;
  jacerr=ptsProjRTJac;

  if(doMLSL)
  {
  double lb[NUM_RTPARAMS], ub[NUM_RTPARAMS], minL2sq;
  double scl[NUM_RTPARAMS];

    /* setup bounds & expected magnitudes; translation in mm -- CHECKME */
    if(!inpl){
      if(verbose) printf("PnP pose: %g %g %g %g %g %g\n", p[0], p[1], p[2], p[3], p[4], p[5]);
      scl[0]=1.0;  scl[1]=2.0;  scl[2]=1.0;
      scl[3]=300.; scl[4]=300.; scl[5]=1500.;

      lb[0]=-1.5+p[0];    ub[0]=1.5+p[0];
      lb[1]=-1.5+p[1];    ub[1]=1.5+p[1];
      lb[2]=-1.5+p[2];    ub[2]=1.5+p[2];
      lb[3]=-300.+p[3];   ub[3]=300.+p[3];
      lb[4]=-300.+p[4];   ub[4]=300.+p[4];
      lb[5]=-700.+p[5];   ub[5]=700.+p[5];
    }
    else{ // in-place
      if(verbose) printf("Init refinement to PnP pose (in-place): %g %g %g %g %g %g\n", p[0], p[1], p[2], p[3], p[4], p[5]);
      scl[0]=1.0;        scl[1]=1.0;        scl[2]=1.0;
      scl[3]=fabs(p[3]); scl[4]=fabs(p[4]); scl[5]=fabs(p[5]);

      lb[0]=-1.5+p[0];    ub[0]=1.5+p[0];
      lb[1]=-1.5+p[1];    ub[1]=1.5+p[1];
      lb[2]=-1.5+p[2];    ub[2]=1.5+p[2];
      lb[3]=-1000.+p[3];  ub[3]=1000.+p[3];
      lb[4]=-1000.+p[4];  ub[4]=1000.+p[4];
      lb[5]=-1500.+p[5];  ub[5]=1500.+p[5];
    }

# if 0
    printf("L bounds: %g %g %g %g %g %g\n", lb[0], lb[1], lb[2], lb[3], lb[4], lb[5]);
    printf("U bounds: %g %g %g %g %g %g\n", ub[0], ub[1], ub[2], ub[3], ub[4], ub[5]);
#endif

    /* refine PnP pose and use it to initiate MLSL */
    ret=dlevmar_der(err, jacerr, p, x, m, n, 1000, opts, info, NULL, NULL, (void *)data); // with analytic Jacobian

    mlsl_dlevmar_der(err, jacerr, p, x, m, n, lb, ub, scl, 500, opts, info, NULL, NULL, (void *)data, &minL2sq, 5, 1, verbose);
    if(verbose) printf("MLSL pose: %g %g %g %g %g %g, error %g\n", p[0], p[1], p[2], p[3], p[4], p[5], minL2sq/ninl);
  }

#if USE_ROBUST_LM==0
  ret=dlevmar_der(err, jacerr, p, x, m, n, 1000, opts, info, NULL, NULL, (void *)data); // with analytic Jacobian
  //ret=dlevmar_dif(err, p, x, m, n, 1000, opts, info, NULL, NULL, (void *)data); // no Jacobian
#else
  { double rp[2];

# if 0
  // attempt to estimate scale from the data
  double ls[2];
  int est=LM_HAMPEL_LOCSCL; // LM_ROUSSEEUW_LOCSCL

  ret=dlevmar_der(err, jacerr, p, x, m, n, 1000, opts, info, NULL, NULL, (void *)data); // with analytic Jacobian
  dlevmar_locscale(err, p, x, m, n, (void *)data, est, ls, NULL);
# endif

  /* use convex cost function first, then non-convex */
  rp[0]=LM_FAIR; rp[1]=0.6; // Fair
  ret=dlevmar_rob_der(err, jacerr, p, x, m, n, rp, 1000, opts, info, NULL, NULL, (void *)data);
  //rp[0]=LM_TUKEY; rp[1]=0.20; // Tukey
  rp[0]=LM_GEMANMCCLURE; rp[1]=0.25; // Geman-McClure
  ret=dlevmar_rob_der(err, jacerr, p, x, m, n, rp, 100, opts, info, NULL, NULL, (void *)data);
  }
#endif /* USE_ROBUST_LM */

  if(verbose){
    fprintf(stdout, "\nRefinement using %d measurements, %d variables\n", n, m);
    fprintf(stdout, "LM returned %d in %g iter, reason %g, error %g [initial %g], %d/%d func/fjac evals\n",
                    ret, info[5], info[6], info[1]/ninl, info[0]/ninl, (int)info[7], (int)info[8]);
#if 0
    fprintf(stdout, "\nSolution: ");
    for(i=0; i<m; ++i)
      fprintf(stdout, "%.7g ", p[i]);
    fprintf(stdout, "\n");
#endif
  }

  free(x);

  return ret;
}

/* nonlinear refinement of camera pose using an in-place parameterization;
 * based on minimizing reprojection error
 *
 * Posest computes the pose Rp,t transforming points from bundler to camera frame:
 * Mc=Rp*Mb + tp (1)
 * The in-place refinement computes a correction dR,dt so that
 * Mc'=dR*(Mc-C) + C + dt (2), with C being the center of rotation (the point's
 * centroid). Therefore, substituting (1) into (2) gives
 * Mc'=dR*Rp*Mb + dR*(tp-C) + C + dt,
 * which gives the overall pose in posest's convention (bundler to camera) as
 * R=dR*Rp, t=dR*(tp-C) + C + dt
 *
 * Note also that (2) implies that dR,C+dt can be estimated with refinePoseRT()
 * applied to the transformed input points (Mc-C)
 */
static int refinePoseRT_inplace(double *p, struct RTdata *data, int doMLSL, int verbose)
{
register int i, j;
int ninl=data->numInliers;
int *inliersidx=data->inliersidx;
double (*pts3D)[3]=data->pts3D, X, Y, Z, dp[NUM_RTPARAMS];
double cent[3], // C
       Rp[9], tp[3], // PnP pose estimate (from RANSAC)
       tp_cent[3], // tp-C
       dR[9], totR[9];
int ret;

  if(verbose) printf("PnP pose: %g %g %g %g %g %g\n", p[0], p[1], p[2], p[3], p[4], p[5]);

  /* compute points centroid */
  cent[0]=cent[1]=cent[2]=0.0;
  for(i=0; i<ninl; ++i){
    j=data->inliersidx[i];
    cent[0]+=pts3D[j][0];
    cent[1]+=pts3D[j][1];
    cent[2]+=pts3D[j][2];
  }
  cent[0]/=(double)ninl; cent[1]/=(double)ninl; cent[2]/=(double)ninl;

  /* transform 3D points with supplied pose & translate centroid to origin: Rp*M+tp-cent */
  rvec2rotmat(p, Rp);
  tp[0]=p[3]; tp[1]=p[4]; tp[2]=p[5];
  tp_cent[0]=tp[0]-cent[0]; tp_cent[1]=tp[1]-cent[1]; tp_cent[2]=tp[2]-cent[2];
  for(i=0; i<ninl; ++i){
    j=data->inliersidx[i];
    X=pts3D[j][0]; Y=pts3D[j][1]; Z=pts3D[j][2];
    pts3D[j][0]=Rp[0]*X + Rp[1]*Y + Rp[2]*Z + tp_cent[0];
    pts3D[j][1]=Rp[3]*X + Rp[4]*Y + Rp[5]*Z + tp_cent[1];
    pts3D[j][2]=Rp[6]*X + Rp[7]*Y + Rp[8]*Z + tp_cent[2];
  }

  /* estimate in-place pose refinement */
  dp[0]=1E-04; dp[1]=dp[2]=0.0; // dR=I, avoid singular case with r=[0 0 0]
  dp[3]=cent[0]; dp[4]=cent[1]; dp[5]=cent[2]; // we are actually estimating C+dt, initial dt=[0 0 0]

  ret=refinePoseRT(dp, data, doMLSL, 1, verbose);

  /* undo changes to 3D points: Rp'*(M-(tp-cent)) */
  for(i=0; i<ninl; ++i){
    j=data->inliersidx[i];
    X=pts3D[j][0]-(tp_cent[0]); Y=pts3D[j][1]-(tp_cent[1]); Z=pts3D[j][2]-(tp_cent[2]);
    pts3D[j][0]=Rp[0]*X + Rp[3]*Y + Rp[6]*Z;
    pts3D[j][1]=Rp[1]*X + Rp[4]*Y + Rp[7]*Z;
    pts3D[j][2]=Rp[2]*X + Rp[5]*Y + Rp[8]*Z;
  }

  if(ret==LM_ERROR) goto bailout;

  /* incorporate estimated in-place pose to p */
  rvec2rotmat(dp, dR);
  /* totR=dR*Rp */
  for(i=0; i<3; ++i)
    for(j=0; j<3; ++j)
      totR[i*3+j]=dR[i*3]*Rp[j] + dR[i*3+1]*Rp[3+j] + dR[i*3+2]*Rp[2*3+j];
  rotmat2rodr(totR, p); // sets p[0:2]

  /* dR*(tp-cent) + C+dt */
  p[3]=dR[0]*tp_cent[0] + dR[1]*tp_cent[1] + dR[2]*tp_cent[2] + dp[3];
  p[4]=dR[3]*tp_cent[0] + dR[4]*tp_cent[1] + dR[5]*tp_cent[2] + dp[4];
  p[5]=dR[6]*tp_cent[0] + dR[7]*tp_cent[1] + dR[8]*tp_cent[2] + dp[5];

  if(verbose){
#if 0
    fprintf(stdout, "\nSolution: ");
    for(i=0; i<NUM_RTPARAMS; ++i)
      fprintf(stdout, "%.7g ", p[i]);
    fprintf(stdout, "\n");
#endif
  }

bailout:

  return ret;
}

/* Robust, non-linear 2D-3D pose estimation from "nmatches" matched point features, possibly
 * including outliers. "pts2D", "pts3D" contain the matched 2D-3D point coordinates,
 * "inlPcent" is the expected percentage of inliers (>=0.5), "rt" contains the estimated pose
 * parameters upon return, "NLrefine" specifies which cost function should be employed for the
 * non-linear refinement step (see posest.h for appropriate values), "idxOutliers" points to
 * sufficiently large memory which upon return is set to the indices of the detected outlying
 * points (pass NULL if don't care), "nbOutliers" contains the number of outliers, "verbose"
 * specifies the verbosity level
 */
static int posestRT(double (*pts2D)[2], double (*pts3D)[3], int nmatches, double inlPcent, double K[9],
           double rt[NUM_RTPARAMS], int NLrefine, int *idxOutliers, int *nbOutliers, int verbose)
{
register int i, j;
int isSqr=1, maxNbSol;
double gate=2.0, premResid=-1.0, sampleProb=0.99, outlierThresh;
int *outliersMap, ret, **sets=NULL, nbSets=0;
struct RTdata dat;
int verbosein=verbose;

  if(nmatches<NUM_PNPMATCHES) return POSEST_ERR;  // too few matches

#if (USE_LQS_FIT==1) || (USE_RANSAC_FIT==1) || (USE_MLESAC_FIT==1)
  nbSets=10*lqs_numtries(NUM_PNPMATCHES, inlPcent, sampleProb); // ten times those theoretically necessary
  sets=lqs_allocsets(NUM_PNPMATCHES, nbSets);

#ifdef USE_BUCKETS
  nbSets=posest_genRandomSetsWithBuckets(pts2D, NUM_PNPMATCHES, nmatches, nbSets, sets);
#else
  nbSets=posest_genRandomSetsNoBuckets(NUM_PNPMATCHES, nmatches, nbSets, sets);
#endif /* USE_BUCKETS */

#endif /* (USE_LQS_FIT==1) || (USE_RANSAC_FIT==1) || (USE_MLESAC_FIT==1) */

  dat.pts2D=pts2D; dat.pts3D=pts3D;
  dat.K=K;
  p3p_set_calib(&dat.cal, K);
  dat.inliersidx=NULL;

  if(!(outliersMap=(int *)malloc(nmatches*sizeof(int)))){
    fprintf(stderr, "Error: not enough memory for 'outliersMap' in posestRT()\n");
    exit(1);
  }
  verbose=verbose>1;

  maxNbSol=(NUM_PNPMATCHES==3)? MAX_NUM_P3P_SOL : 1;
#if USE_LQS_FIT==1
  j=lqsfit(nmatches, NUM_PNPMATCHES, sets, nbSets, poseRTResidualsGeom, estP3PPose,
            isSqr, verbose, maxNbSol, gate, premResid, NUM_RTPARAMS, inlPcent, (void *)&dat,
            rt, NULL, outliersMap, nbOutliers, &outlierThresh);
#elif (USE_RANSAC_FIT==1) || (USE_PROSAC_FIT==1) || (USE_MLESAC_FIT==1)
  gate=premResid=0; /* -Wall */
  //outlierThresh=ransac_getthresh(0.8, 2); // assume s=.8, symmetric distance involves 2 squared terms
  //outlierThresh=sqrt(0.8*0.8*9.210340372); // assume s=.8, symmetric distance involves 2 squared terms
  
  outlierThresh=RANSAC_OUTL_THRESH;

# if USE_RANSAC_FIT==1
  j=ransacfit(nmatches, NUM_PNPMATCHES, sets, nbSets, poseRTResidualsGeom, estP3PPose,
            isSqr, verbose, maxNbSol, outlierThresh, 0, NUM_RTPARAMS, inlPcent, (void *)&dat,
            rt, NULL, outliersMap, nbOutliers);
# elif USE_MLESAC_FIT==1
  j=mlesacfit(nmatches, NUM_PNPMATCHES, sets, nbSets, poseRTResidualsGeom, estP3PPose,
            isSqr, verbose, maxNbSol, outlierThresh, 0, NUM_RTPARAMS, inlPcent, (void *)&dat,
            rt, NULL, outliersMap, nbOutliers);
# else
  j=prosacfit(nmatches, NUM_PNPMATCHES, poseRTResidualsGeom, estP3PPose,
            isSqr, verbose, maxNbSol, outlierThresh, 0, NUM_RTPARAMS, inlPcent, (void *)&dat,
            rt, NULL, outliersMap, nbOutliers);
# endif
#endif /* USE_LQS_FIT */

  if(verbose){
    fprintf(stderr, "Outlier threshold: %g\n", outlierThresh);
    fprintf(stderr, "posestRT(): robust fit returned %d, %d outliers [out of %d]\n", j, *nbOutliers, nmatches);
  }

  if(sets) lqs_freesets(sets);

  dat.numInliers=nmatches - *nbOutliers;
  if(j!=0){
    dat.inliersidx=(int *)malloc(dat.numInliers*sizeof(int));
    if(!dat.inliersidx){
      fprintf(stderr, "Error: not enough memory for 'dat.inliersidx' in posestRT()\n");
      exit(1);
    }

    for(i=j=0; i<nmatches; ++i)
      if(!outliersMap[i]) dat.inliersidx[j++]=i;

#if 0
    /* LS estimation on inliers */
    estP3PPose(rt, dat.numInliers, dat.inliersidx, (void *)&dat);
#endif

    /* expose outliers */
    if(idxOutliers!=NULL)
      for(i=j=0; i<nmatches; ++i)
        if(outliersMap[i]) idxOutliers[j++]=i;

#if 0
    if(verbose){
      fputs("Outliers: ", stderr);
      for(i=j=0; i<nmatches; ++i)
        if(outliersMap[i]) fprintf(stderr, "%d ", i);
      fputc('\n', stderr);
    }
#endif

    ret=POSEST_OK;

#if 0
    /* include the following code fragment to print the matching 3D-2D points found to be inlying */
    for(i=0; i<dat.numInliers; ++i){
      printf("%.4lf %.4lf %.4lf  %.4lf %.4lf\n", pts3D[dat.inliersidx[i]][0], pts3D[dat.inliersidx[i]][1], pts3D[dat.inliersidx[i]][2],
                                          pts2D[dat.inliersidx[i]][0], pts2D[dat.inliersidx[i]][1]);
    }
#endif

  }
  else{ /* robust fit failed */
    memset(rt, 0, NUM_RTPARAMS*sizeof(double));
    *nbOutliers=nmatches;
    dat.numInliers=0; /* makes sure the non-linear refinement below is avoided */
    ret=POSEST_ERR;
  }

  /* the initial estimate has now been computed. Time for the non-linear refinement */
  if(2*dat.numInliers>=NUM_RTPARAMS && NLrefine!=POSEST_REPR_ERR_NO_NLN_REFINE){
    int withMLSL=(NLrefine==POSEST_REPR_ERR_NLN_MLSL_REFINE);

    sam_rvecnorm(rt); // map rotation angle to [-pi, pi]

#  if USE_INPLACE_REFN==0
    j=refinePoseRT(rt, &dat, withMLSL, 0, verbosein);
#  else
    j=refinePoseRT_inplace(rt, &dat, withMLSL, verbosein);
#  endif

    ret=(j!=LM_ERROR)? POSEST_OK : POSEST_ERR;
    sam_rvecnorm(rt); // map rotation angle to [-pi, pi]
  }

  if(dat.inliersidx) free(dat.inliersidx);
  free(outliersMap);

  return ret;
}

/***** robust nonlinear estimation of focal length, rotation and translation *****/

/* variables used by various estimation routines */
struct RTFdata {
  double u0v0[2]; // principal point
  double (*pts2D)[2], (*pts3D)[3];
  int *inliersidx, numInliers;
};


/* estimate "point" pose P=K[R t] s.t. m=P*M, with m, M specified by ptsidx */
static int estP4PfPose(double *rtf, int npts, int *ptsidx, void *adata)
{
int nposes;
struct RTFdata *dat=(struct RTFdata *)adata;
double (*pts2D)[2]=dat->pts2D, (*pts3D)[3]=dat->pts3D;
double *m0, *m1, *m2, *m3, *M0, *M1, *M2, *M3;
double m[4][2], M[4][3], *prtf;
double R[MAX_NUM_P4PF_SOL][3][3], t[MAX_NUM_P4PF_SOL][3], foc[MAX_NUM_P4PF_SOL];
register int i, j;


  if(npts<NUM_P4PFMATCHES) return 0; // not enough points

  m0=pts2D[ptsidx[0]]; M0=pts3D[ptsidx[0]];
  m1=pts2D[ptsidx[1]]; M1=pts3D[ptsidx[1]];
  m2=pts2D[ptsidx[2]]; M2=pts3D[ptsidx[2]];
  m3=pts2D[ptsidx[3]]; M3=pts3D[ptsidx[3]];

#if 0
/* print matching points for matlab */
printf("\n=======================================\n");
printf("m=[");
for(i=0; i<2; ++i)
  printf("%g %g %g %g\n", m0[i], m1[i], m2[i], m3[i]);
printf("]\nM=[");
for(i=0; i<3; ++i)
  printf("%g %g %g %g\n", M0[i], M1[i], M2[i], M3[i]);
printf("]\n");
printf("\n=======================================\n");
fflush(stdout);
#endif

  for(i=0; i<2; ++i){
    m[0][i]=m0[i]; m[1][i]=m1[i]; m[2][i]=m2[i]; m[3][i]=m3[i];
    M[0][i]=M0[i]; M[1][i]=M1[i]; M[2][i]=M2[i]; M[3][i]=M3[i];
  }
  M[0][2]=M0[2]; M[1][2]=M1[2]; M[2][2]=M2[2]; M[3][2]=M3[2];

  /* solve P4Pf */
  nposes=p4pf_solve(m, M, R, t, foc);

  for(i=j=0; i<nposes; ++i){
    prtf=rtf+j*NUM_RTFPARAMS;
    if(!rotmat2rodr((double *)R[i], prtf)){
      prtf[3]=t[i][0];
      prtf[4]=t[i][1];
      prtf[5]=t[i][2];
      prtf[6]=foc[i];
      ++j;
    }
  }
    
  return j;
}

/* compute the geometric residuals corresponding to pose as the (squared) distance between actual and predicted point */
static void poseRTFResidualsGeom(double rtf[NUM_RTFPARAMS], int numres, void *adata, double *resid)
{
register int i;
double K[9], P[NUM_PPARAMS], X, Y, Z, s, ppt[2];
struct RTFdata *dat=(struct RTFdata *)adata;
double (*pts2D)[2]=dat->pts2D, (*pts3D)[3]=dat->pts3D;

  /* NOTE: no u0v0 here! */
  K[0]=rtf[NUM_RTFPARAMS-1]; K[1]=0.0;  K[2]=0.0;
  K[3]=0.0;                  K[4]=K[0]; K[5]=0.0;
  K[6]=0.0;                  K[7]=0.0;  K[8]=1.0;
  /* P=K[R t] */
  posest_PfromKRt(P, K, rtf);

  for(i=0; i<numres; ++i){
    /* project 3D point */
    X=pts3D[i][0]; Y=pts3D[i][1]; Z=pts3D[i][2];
     s=1.0/(P[8]*X + P[9]*Y + P[10]*Z + P[11]);
    ppt[0]=(P[0]*X + P[1]*Y + P[2]*Z  + P[3])*s;
    ppt[1]=(P[4]*X + P[5]*Y + P[6]*Z  + P[7])*s;

    ppt[0]-=pts2D[i][0]; ppt[1]-=pts2D[i][1];
    resid[i]=(SQR(ppt[0]) + SQR(ppt[1]));
  }
}

/* reprojection error and Jacobian */
static void ptsProjRTF(double *rtf, double *x, int m, int n, void *adata)
{
struct RTFdata *dat=(struct RTFdata *)adata;
int ninl=dat->numInliers, *inlidx=dat->inliersidx;
double (*pts3D)[3]=dat->pts3D, *u0v0=dat->u0v0;
register int i;

  for(i=0; i<ninl; ++i){
    calc_poseProjRTF(rtf, u0v0, pts3D[inlidx[i]], x+i*2);

  }
}

static void ptsProjRTFJac(double *rtf, double *jac, int m, int n, void *adata)
{
register int i;
struct RTFdata *dat=(struct RTFdata *)adata;
int ninl=dat->numInliers, *inlidx=dat->inliersidx;
double (*pts3D)[3]=dat->pts3D, *u0v0=dat->u0v0;
register double *jacrow;

  //memset(jac, 0, m*n*sizeof(double));

  for(i=0, jacrow=jac; i<ninl; ++i, jacrow+=2*m){
    calc_poseProjRTFJac(rtf, u0v0, pts3D[inlidx[i]], jacrow, jacrow+m);
  }
}


/* nonlinear refinement of camera pose & foc. length; based on minimizing reprojection error */

/** NOTE: MLSL not implemented for this case yet!*/
static int refinePoseRTF(double *p, struct RTFdata *data, int verbose)
{
register int i, j;
double opts[LM_OPTS_SZ], info[LM_INFO_SZ], *x;
int m, n; // # unknowns & # constraints
int ninl=data->numInliers;
void (*err)(double *p, double *hx, int m, int n, void *adata);
void (*jacerr)(double *p, double *j, int m, int n, void *adata);
int ret;

  opts[0]=LM_INIT_MU; opts[1]=1E-12; opts[2]=1E-12; opts[3]=1E-15;
  opts[4]=LM_DIFF_DELTA; // relevant only if the finite difference Jacobian version is used 

  m=NUM_RTFPARAMS; n=2*ninl; // two measurements per point
  if((x=(double *)malloc(n*sizeof(double)))==NULL){
    fprintf(stderr, "Memory allocation request failed in refinePoseRTF()\n");
    exit(1);
  }
  for(i=0; i<ninl; ++i){
    j=i<<1; // 2*i
    x[j]  =data->pts2D[data->inliersidx[i]][0];
    x[j+1]=data->pts2D[data->inliersidx[i]][1];
  }
  err=ptsProjRTF;
  jacerr=ptsProjRTFJac;

#if USE_ROBUST_LM==0
  ret=dlevmar_der(err, jacerr, p, x, m, n, 1000, opts, info, NULL, NULL, (void *)data); // with analytic Jacobian
  //ret=dlevmar_dif(err, p, x, m, n, 1000, opts, info, NULL, NULL, (void *)data); // no Jacobian
#else
  { double rp[2];

  /* convex cost function first, then non-convex */
  rp[0]=LM_FAIR; rp[1]=0.6; // Fair
  ret=dlevmar_rob_der(err, jacerr, p, x, m, n, rp, 1000, opts, info, NULL, NULL, (void *)data);
  //rp[0]=LM_TUKEY; rp[1]=0.20; // Tukey
  rp[0]=LM_GEMANMCCLURE; rp[1]=0.25; // Geman-McClure
  ret=dlevmar_rob_der(err, jacerr, p, x, m, n, rp, 100, opts, info, NULL, NULL, (void *)data);
  }
#endif /* USE_ROBUST_LM */

  if(verbose){
    fprintf(stdout, "\nRefinement using %d measurements, %d variables\n", n, m);
    fprintf(stdout, "LM returned %d in %g iter, reason %g, error %g [initial %g], %d/%d func/fjac evals\n",
                    ret, info[5], info[6], info[1]/ninl, info[0]/ninl, (int)info[7], (int)info[8]);
#if 0
    fprintf(stdout, "\nSolution: ");
    for(i=0; i<m; ++i)
      fprintf(stdout, "%.7g ", p[i]);
    fprintf(stdout, "\n");
#endif
  }

  free(x);

  return ret;
}

/* Robust, non-linear 2D-3D pose + foc. length estimation from "nmatches" matched point features,
 * possibly including outliers. "inpts2D", "pts3D" contain the matched 2D-3D point coordinates,
 * "inlPcent" is the expected percentage of inliers (>=0.5), "rtf" contains the estimated pose
 * parameters upon return, "NLrefine" specifies which cost function should be employed for the
 * non-linear refinement step (see posest.h for appropriate values), "idxOutliers" points to
 * sufficiently large memory which upon return is set to the indices of the detected outlying
 * points (pass NULL if don't care), "nbOutliers" contains the number of outliers, "verbose"
 * specifies the verbosity level
 */
static int posestRTF(double (*inpts2D)[2], double (*pts3D)[3], int nmatches, double inlPcent, double K[9],
           double rtf[NUM_RTFPARAMS], int NLrefine, int *idxOutliers, int *nbOutliers, int verbose)
{
register int i, j;
int isSqr=1, maxNbSol;
double gate=2.0, premResid=-1.0, sampleProb=0.99, outlierThresh;
int *outliersMap, ret, **sets=NULL, nbSets=0;
double (*pts2D)[2], u0, v0;
struct RTFdata dat;
int verbosein=verbose;

  if(nmatches<NUM_P4PFMATCHES) return POSEST_ERR;  // too few matches

  pts2D=(double (*)[2])malloc(nmatches*sizeof(double[2]));
  if(!pts2D){
    fprintf(stderr, "Memory allocation request failed in posestRTF()\n");
    exit(1);
  }

  /* remove p. pt */
  u0=K[2]; v0=K[5];
  for(i=nmatches; i-->0; ){
    pts2D[i][0]=inpts2D[i][0]-u0;
    pts2D[i][1]=inpts2D[i][1]-v0;
  }

#if (USE_LQS_FIT==1) || (USE_RANSAC_FIT==1) || (USE_MLESAC_FIT==1)
  nbSets=10*lqs_numtries(NUM_P4PFMATCHES, inlPcent, sampleProb); // ten times those theoretically necessary
  sets=lqs_allocsets(NUM_P4PFMATCHES, nbSets);

#ifdef USE_BUCKETS
  nbSets=posest_genRandomSetsWithBuckets(pts2D, NUM_P4PFMATCHES, nmatches, nbSets, sets);
#else
  nbSets=posest_genRandomSetsNoBuckets(NUM_P4PFMATCHES, nmatches, nbSets, sets);
#endif /* USE_BUCKETS */

#endif /* (USE_LQS_FIT==1) || (USE_RANSAC_FIT==1) || (USE_MLESAC_FIT==1) */

  dat.pts2D=pts2D; dat.pts3D=pts3D;
  dat.u0v0[0]=u0; dat.u0v0[1]=v0;
  dat.inliersidx=NULL;

  if(!(outliersMap=(int *)malloc(nmatches*sizeof(int)))){
    fprintf(stderr, "Error: not enough memory for 'outliersMap' in posestRTF()\n");
    exit(1);
  }
  verbose=verbose>1;

  maxNbSol=MAX_NUM_P4PF_SOL;
#if USE_LQS_FIT==1
  j=lqsfit(nmatches, NUM_P4PFMATCHES, sets, nbSets, poseRTFResidualsGeom, estP4PfPose,
            isSqr, verbose, maxNbSol, gate, premResid, NUM_RTFPARAMS, inlPcent, (void *)&dat,
            rtf, NULL, outliersMap, nbOutliers, &outlierThresh);
#elif (USE_RANSAC_FIT==1) || (USE_PROSAC_FIT==1) || (USE_MLESAC_FIT==1)
  gate=premResid=0; /* -Wall */
  //outlierThresh=ransac_getthresh(0.8, 2); // assume s=.8, symmetric distance involves 2 squared terms
  //outlierThresh=sqrt(0.8*0.8*9.210340372); // assume s=.8, symmetric distance involves 2 squared terms
  
  outlierThresh=RANSAC_OUTL_THRESH;
# if USE_RANSAC_FIT==1
  j=ransacfit(nmatches, NUM_P4PFMATCHES, sets, nbSets, poseRTFResidualsGeom, estP4PfPose,
            isSqr, verbose, maxNbSol, outlierThresh, 0, NUM_RTFPARAMS, inlPcent, (void *)&dat,
            rtf, NULL, outliersMap, nbOutliers);
# elif USE_MLESAC_FIT==1
  j=mlesacfit(nmatches, NUM_P4PFMATCHES, sets, nbSets, poseRTFResidualsGeom, estP4PfPose,
            isSqr, verbose, maxNbSol, outlierThresh, 0, NUM_RTFPARAMS, inlPcent, (void *)&dat,
            rtf, NULL, outliersMap, nbOutliers);
# else
  j=prosacfit(nmatches, NUM_P4PFMATCHES, poseRTFResidualsGeom, estP4PfPose,
            isSqr, verbose, maxNbSol, outlierThresh, 0, NUM_RTFPARAMS, inlPcent, (void *)&dat,
            rtf, NULL, outliersMap, nbOutliers);
# endif
#endif /* USE_LQS_FIT */

  if(verbose){
    fprintf(stderr, "Outlier threshold: %g\n", outlierThresh);
    fprintf(stderr, "posestRTF(): robust fit returned %d, %d outliers [out of %d]\n", j, *nbOutliers, nmatches);
  }

  if(sets) lqs_freesets(sets);

  dat.numInliers=nmatches - *nbOutliers;
  if(j!=0){
    dat.inliersidx=(int *)malloc(dat.numInliers*sizeof(int));
    if(!dat.inliersidx){
      fprintf(stderr, "Error: not enough memory for 'dat.inliersidx' in posestRTF()\n");
      exit(1);
    }

    for(i=j=0; i<nmatches; ++i)
      if(!outliersMap[i]) dat.inliersidx[j++]=i;

#if 0
    /* LS estimation on inliers */
    estP4PfPose(rtf, dat.numInliers, dat.inliersidx);
#endif

    /* expose outliers */
    if(idxOutliers!=NULL)
      for(i=j=0; i<nmatches; ++i)
        if(outliersMap[i]) idxOutliers[j++]=i;

#if 0
    if(verbose){
      fputs("Outliers: ", stderr);
      for(i=j=0; i<nmatches; ++i)
        if(outliersMap[i]) fprintf(stderr, "%d ", i);
      fputc('\n', stderr);
    }
#endif

    ret=POSEST_OK;

#if 0
    /* include the following code fragment to print the matching 3D-2D points found to be inlying */
    for(i=0; i<dat.numInliers; ++i){
      printf("%.4lf %.4lf %.4lf  %.4lf %.4lf\n", pts3D[dat.inliersidx[i]][0], pts3D[dat.inliersidx[i]][1], pts3D[dat.inliersidx[i]][2],
                                          inpts2D[dat.inliersidx[i]][0], inpts2D[dat.inliersidx[i]][1]);
    }
#endif

  }
  else{ /* robust fit failed */
    memset(rtf, 0, NUM_RTFPARAMS*sizeof(double));
    *nbOutliers=nmatches;
    dat.numInliers=0; /* makes sure the non-linear refinement below is avoided */
    ret=POSEST_ERR;
  }

  /* the initial estimate has now been computed. Time for the non-linear refinement */
  if(2*dat.numInliers>=NUM_RTFPARAMS && NLrefine!=POSEST_REPR_ERR_NO_NLN_REFINE){
    //int withMLSL=(NLrefine==POSEST_REPR_ERR_NLN_MLSL_REFINE);

    /* use the actual 2D points for the refinement */
    dat.pts2D=inpts2D;
    j=refinePoseRTF(rtf, &dat, verbosein);
    ret=(j!=LM_ERROR)? POSEST_OK : POSEST_ERR;
  }

  if(dat.inliersidx) free(dat.inliersidx);
  free(outliersMap);

  free(pts2D);

  return ret;
}


/* Driver routine for robust, non-linear 2D-3D pose estimation from "nmatches" matched point
 * features, possibly including outliers. "pts2D", "pts3D" contain the matched 2D-3D point
 * coordinates, "inlPcent" is the expected percentage of inliers (>=0.5), "pp" contains the
 * estimated pose parameters upon return, "npp" specifies the number of parameters to be
 * estimated:
 *    -a value of NUM_RTPARAMS specifies that r & t are estimated (6 in total)
 *    -a value of NUM_RTFPARAMS specifies that r, t & f are estimated (6+1 in total),
 * "NLrefine" specifies which cost function should be employed for the
 * non-linear refinement step (see posest.h for appropriate values), "idxOutliers" points to
 * sufficiently large memory which upon return is set to the indices of the detected outlying
 * points (pass NULL if don't care), "nbOutliers" contains the number of outliers, "verbose"
 * specifies the verbosity level
 */
int posest(double (*pts2D)[2], double (*pts3D)[3], int nmatches, double inlPcent, double K[9],
           double *pp, int npp, int NLrefine, int *idxOutliers, int *nbOutliers, int verbose)
{
  if(NLrefine!=POSEST_OBJSPC_ERR_LHM){
    switch(npp){
      case NUM_RTPARAMS:
        return posestRT(pts2D, pts3D, nmatches, inlPcent, K, pp, NLrefine, idxOutliers, nbOutliers, verbose);
      break;

      case NUM_RTFPARAMS:
        return posestRTF(pts2D, pts3D, nmatches, inlPcent, K, pp, NLrefine, idxOutliers, nbOutliers, verbose);
      break;

      default:
        fprintf(stderr, "unknown pose estimation case '%d' specified to posest()\n", npp);
        exit(1);
    }
  }
  else{
    if(npp==NUM_RTFPARAMS){
      fprintf(stderr, "'NUM_RTFPARAMS' not supported in combination with 'POSEST_OBJSPC_ERR_LHM' in posest()\n");
      exit(1);
    }
#if 1
    /* initialize LHM with the weak perspective approximation */
    return posestRT_LHM(pts2D, pts3D, nmatches, inlPcent, K, LHM_INITR_WEAKP, pp, idxOutliers, nbOutliers, verbose);
#else
    /* initialize LHM with the rotation estimated by posestRT */
    pp[0]=pp[1]=pp[2]=0.0; // initialize rotation in case posestRT below fails...
    posestRT(pts2D, pts3D, nmatches, inlPcent, K, pp, POSEST_REPR_ERR_NO_NLN_REFINE, idxOutliers, nbOutliers, verbose); // no refinement
    return posestRT_LHM(pts2D, pts3D, nmatches, inlPcent, K, LHM_INITR_SUPPLIED, pp, idxOutliers, nbOutliers, verbose);
#endif
  }

  return POSEST_ERR; // should not reach this point
}


/***** utility functions *****/

/* Compute the Root Mean Squared (RMS) and Root Median Squared (RMedS) reprojection error
 * pertaining to a camera matrix P that has been estimated from 2D-3D correspondences points.
 * Note that the RMS measure is sensitive to mismatched points while the RMedS is not
 */

#define _MEDIAN_(a, n) lqs_kth_smallest(a, n, (((n)&1)? ((n)/2) : (((n)/2)-1)))

void posest_RMS_RMedS(double (*pts2D)[2], double (*pts3D)[3], int nmatches, double P[NUM_PPARAMS],
                 double *rms, double *rmeds)
{
register int i;
double *errors, sum, q[2], s, dist;
double X, Y, Z;

  if((errors=(double *)malloc(nmatches*sizeof(double)))==NULL){
     fprintf(stderr, "Memory allocation request failed in posest_RMS_RMedS() %d\n", nmatches);
     exit(1);
  }

  for(i=0, sum=0.0; i<nmatches; ++i){
    /* project pts3D[i] using P */
    X=pts3D[i][0]; Y=pts3D[i][1]; Z=pts3D[i][2];

      q[0]=P[0]*X + P[1]*Y +  P[2]*Z + P[3];
      q[1]=P[4]*X + P[5]*Y +  P[6]*Z + P[7];
    s=1.0/(P[8]*X + P[9]*Y + P[10]*Z + P[11]);
    q[0]*=s; q[1]*=s;

    q[0]-=pts2D[i][0];
    q[1]-=pts2D[i][1];

    dist=SQR(q[0]) + SQR(q[1]);
    sum+=errors[i]=dist;
  }

  *rms=sqrt(sum/(double)(nmatches));
  *rmeds=sqrt(_MEDIAN_(errors, nmatches));

  free(errors);
}

/* Compute the values dividing the reprojection errors into four equal parts.
 * The three values respectively cut off the lowest 25%, 50% and 75% of data.
 *
 */

void posest_quartiles(double (*pts2D)[2], double (*pts3D)[3], int nmatches, double P[NUM_PPARAMS],
                      double *Q1, double *Q2, double *Q3)
{
register int i;
double *errors, q[2], s, dist;
double X, Y, Z;

  if((errors=(double *)malloc(nmatches*sizeof(double)))==NULL){
     fprintf(stderr, "Memory allocation request failed in posest_quartiles()\n");
     exit(1);
  }

  for(i=0; i<nmatches; ++i){
    /* project pts3D[i] using P */
    X=pts3D[i][0]; Y=pts3D[i][1]; Z=pts3D[i][2];

      q[0]=P[0]*X + P[1]*Y +  P[2]*Z + P[3];
      q[1]=P[4]*X + P[5]*Y +  P[6]*Z + P[7];
    s=1.0/(P[8]*X + P[9]*Y + P[10]*Z + P[11]);
    q[0]*=s; q[1]*=s;

    q[0]-=pts2D[i][0];
    q[1]-=pts2D[i][1];

    dist=SQR(q[0]) + SQR(q[1]);
    errors[i]=dist;
  }

  if(Q1) *Q1=sqrt(lqs_kth_smallest(errors, nmatches, (nmatches>>2))); // 25%
  if(Q2) *Q2=sqrt(lqs_kth_smallest(errors, nmatches, (nmatches>>1))); // 50%
  if(Q3) *Q3=sqrt(lqs_kth_smallest(errors, nmatches, nmatches-(nmatches>>2))); // 75%

  free(errors);
}


/* Compute the value below which pct percent of the reprojection errors can be found */
double posest_percentile(double (*pts2D)[2], double (*pts3D)[3], int nmatches, double P[NUM_PPARAMS], double pct)
{
register int i;
double *errors, q[2], s, dist;
double X, Y, Z;

  if((errors=(double *)malloc(nmatches*sizeof(double)))==NULL){
     fprintf(stderr, "Memory allocation request failed in posest_percentile()\n");
     exit(1);
  }

  for(i=0; i<nmatches; ++i){
    /* project pts3D[i] using P */
    X=pts3D[i][0]; Y=pts3D[i][1]; Z=pts3D[i][2];

      q[0]=P[0]*X + P[1]*Y +  P[2]*Z + P[3];
      q[1]=P[4]*X + P[5]*Y +  P[6]*Z + P[7];
    s=1.0/(P[8]*X + P[9]*Y + P[10]*Z + P[11]);
    q[0]*=s; q[1]*=s;

    q[0]-=pts2D[i][0];
    q[1]-=pts2D[i][1];

    dist=SQR(q[0]) + SQR(q[1]);
    errors[i]=dist;
  }

  X=sqrt(lqs_kth_smallest(errors, nmatches, (int)(nmatches*pct))); // pct%

  free(errors);

  return X;
}

/************************ Pose refinement from two sets of 2D-3D correspondences (binocular) ****************************/

struct RTBinocdata {
  double *KL, *KR; // intrinsics
  double (*pts2DL)[2], (*pts3DL)[3];
  double (*pts2DR)[2], (*pts3DR)[3];
  double *stereo_rt; // M_R=stereo_R*M_L + stereo_t
  int *inliersidxL, *inliersidxR, ninlL, ninlR;
};

/* reprojection error and Jacobian, no scale refinement */
static void ptsProjRTBinoc(double rt[NUM_RTPARAMS], double *x, int m, int n, void *adata)
{
struct RTBinocdata *dat=(struct RTBinocdata *)adata;
int ninl, *inlidx;
double *K, (*pts3D)[3], rtR[NUM_RTPARAMS];
register int i;

  /* left */
  ninl=dat->ninlL;
  inlidx=dat->inliersidxL;
  K=dat->KL;
  pts3D=dat->pts3DL;
  for(i=0; i<ninl; ++i){
    calc_poseProjRT(K, rt, pts3D[inlidx[i]], x+i*2);
  }

  /* right */
  /* r_R=stereo_R*rtL, t_R=stereo_R*t_L + stereo_t */
  sam_composeMotionsvec(rt, rt+3, dat->stereo_rt, dat->stereo_rt+3, rtR, rtR+3);

  x+=ninl*2;
  ninl=dat->ninlR;
  inlidx=dat->inliersidxR;
  K=dat->KR;
  pts3D=dat->pts3DR;
  for(i=0; i<ninl; ++i){
    calc_poseProjRT(K, rtR, pts3D[inlidx[i]], x+i*2);
    //calc_poseProjRTBinoc(K, rt, dat->stereo_rt, pts3D[inlidx[i]], x+i*2); // as above but slower
  }
}

static void ptsProjRTBinocJac(double rt[NUM_RTPARAMS], double *jac, int m, int n, void *adata)
{
struct RTBinocdata *dat=(struct RTBinocdata *)adata;
int ninl, *inlidx;
double *K, (*pts3D)[3], *stereo_rt;
register double *jacrow;
register int i;

  /* left */
  ninl=dat->ninlL;
  inlidx=dat->inliersidxL;
  K=dat->KL;
  pts3D=dat->pts3DL;
  for(i=0, jacrow=jac; i<ninl; ++i, jacrow+=2*m){
    calc_poseProjRTJac(K, rt, pts3D[inlidx[i]], jacrow, jacrow+m);
  }

  /* right */
  ninl=dat->ninlR;
  inlidx=dat->inliersidxR;
  K=dat->KR;
  pts3D=dat->pts3DR;
  stereo_rt=dat->stereo_rt;
  for(i=0; i<ninl; ++i, jacrow+=2*m){
    calc_poseProjRTBinocJac(K, rt, stereo_rt, pts3D[inlidx[i]], jacrow, jacrow+m);
  }
}


/* reprojection error and Jacobian, refining scale */
static void ptsProjRTBinocScale(double rts[NUM_RTPARAMS+1], double *x, int m, int n, void *adata)
{
struct RTBinocdata *dat=(struct RTBinocdata *)adata;
int ninl, *inlidx;
double *K, (*pts3D)[3], *pt3D, M[3], rtR[NUM_RTPARAMS], scl;
register int i;

  scl=rts[NUM_RTPARAMS];

  /* left */
  ninl=dat->ninlL;
  inlidx=dat->inliersidxL;
  K=dat->KL;
  pts3D=dat->pts3DL;
  for(i=0; i<ninl; ++i){
    pt3D=pts3D[inlidx[i]];
    M[0]=scl*pt3D[0];
    M[1]=scl*pt3D[1];
    M[2]=scl*pt3D[2];
    calc_poseProjRT(K, rts, M, x+i*2);
  }

  /* right */
  /* r_R=stereo_R*rtL, t_R=stereo_R*t_L + stereo_t */
  sam_composeMotionsvec(rts, rts+3, dat->stereo_rt, dat->stereo_rt+3, rtR, rtR+3);

  x+=ninl*2;
  ninl=dat->ninlR;
  inlidx=dat->inliersidxR;
  K=dat->KR;
  pts3D=dat->pts3DR;
  for(i=0; i<ninl; ++i){
    pt3D=pts3D[inlidx[i]];
    M[0]=scl*pt3D[0];
    M[1]=scl*pt3D[1];
    M[2]=scl*pt3D[2];
    calc_poseProjRT(K, rtR, M, x+i*2);
  }
}

static void ptsProjRTBinocScaleJac(double rts[NUM_RTPARAMS+1], double *jac, int m, int n, void *adata)
{
struct RTBinocdata *dat=(struct RTBinocdata *)adata;
int ninl, *inlidx;
double *K, (*pts3D)[3], *stereo_rt;
register double *jacrow;
register int i;

  /* left */
  ninl=dat->ninlL;
  inlidx=dat->inliersidxL;
  K=dat->KL;
  pts3D=dat->pts3DL;
  for(i=0, jacrow=jac; i<ninl; ++i, jacrow+=2*m){
    calc_poseProjRTScaleJac(K, rts, rts+NUM_RTPARAMS, pts3D[inlidx[i]], jacrow, jacrow+m);
  }

  /* right */
  ninl=dat->ninlR;
  inlidx=dat->inliersidxR;
  K=dat->KR;
  pts3D=dat->pts3DR;
  stereo_rt=dat->stereo_rt;
  for(i=0; i<ninl; ++i, jacrow+=2*m){
    calc_poseProjRTBinocScaleJac(K, rts, rts+NUM_RTPARAMS, stereo_rt, pts3D[inlidx[i]], jacrow, jacrow+m);
  }
}

/* Robust, non-linear 2D-3D pose estimation from matched point features observed by a
 * calibrated stereo rig, possibly including outliers. The pose is estimated with the
 * first (left) camera as reference. An estimate of the pose is first computed from the
 * left frame and then refined by minimizing the reprojection error pertaining to both
 * cameras. The process is repeated by computing the pose from the right frame and
 * finally the best overall solution is chosen as the "binocular pose".
 *
 * "pts2DL", "pts3DL" contain the "nmatchesL" matched 2D-3D point coordinates in the
 * left frame, "pts2DR", "pts3DR" are their counterparts in the right frame, "PextL"
 * and "PextR" are the rig's camera matrices, "inlPcent" is the expected percentage
 * of inliers in the left frame (>=0.5), "inscale" is an estimate of scale used to
 * scale input 3D points prior to further processing (use 1.0 if points are already
 * properly scaled). If estScale>0, then the scale returned is the product of inscale
 * and that estimated. "rtLs" will contain
 * upon return the estimated pose parameters and scale (if estScale>0), "idxOutliersLR"
 * points to sufficiently large memory which upon return is set to the indices of the
 * detected outlying points in the two frames (indices i>=nmatchesL should be interpreted
 * as i-nmatchesL and refer to the right image, pass NULL if don't care), "nbOutliersLR"
 * contains the total number of outliers (L+R), "verbose" specifies the verbosity level
 */

/* nonlinear refinement of pose; based on minimizing reprojection error from a calibrated stereo pair */
int posestBinoc(double (*pts2DL)[2], double (*pts3DL)[3], int nmatchesL, double PextL[NUM_PPARAMS],
                double (*pts2DR)[2], double (*pts3DR)[3], int nmatchesR, double PextR[NUM_PPARAMS],
                double inlPcent, double inscale, double rtLs[NUM_RTPARAMS+1], int estScale, int NLrefine,
                int *idxOutliersLR, int *nbOutliersLR, int verbose)
{
register int i, j, k;
int ret, retLR, noutL, noutR, *outidx, ninlL, ninlR, *inliersidxL=NULL, *inliersidxR=NULL;
double RextL[9], textL[3], KL[9], RextR[9], textR[3], KR[9], R[9], rtRs[NUM_RTPARAMS+1];
double stereoLR_rt[NUM_RTPARAMS], stereoRL_rt[NUM_RTPARAMS]; // motions from L to R and vice-versa (R, t and R', -R'*t)
//double maxreprerrR=4.5; // (deprecated) max. allowable repr. error, used to determine outliers
//const double maxreprerrR_sq=maxreprerrR*maxreprerrR;

double opts[LM_OPTS_SZ], infoLR[LM_INFO_SZ], infoRL[LM_INFO_SZ], *x;
int m, n; // # unknowns & # constraints
struct RTBinocdata data;
void (*err)(double *p, double *hx, int m, int n, void *adata);
void (*jacerr)(double *p, double *j, int m, int n, void *adata);

  if(inscale!=1.0){ // scale 3D points
    for(i=0; i<nmatchesL; ++i){
      pts3DL[i][0]*=inscale;
      pts3DL[i][1]*=inscale;
      pts3DL[i][2]*=inscale;
    }
    for(i=0; i<nmatchesR; ++i){
      pts3DR[i][0]*=inscale;
      pts3DR[i][1]*=inscale;
      pts3DR[i][2]*=inscale;
    }
  }

  /* extract intrinsics & extrinsics from camera matrices and compute relative stereo displacement */
  /* 3D points transform as 
   * M_L=R_L*M + t_L for the left camera and 
   * M_R=R_R*M + t_R == R*R_L*M + R*t_L + t for the right
   * where M_R=R*M_L + t
   */ 
  sam_KRtfromP(PextL, KL, RextL, textL);
  sam_KRtfromP(PextR, KR, RextR, textR);
  sam_relMotion(RextL, textL, RextR, textR, R, stereoLR_rt+3); // R, t s.t. RextR=R*RextL, textR=R*textL+t
  sam_rotmat2vec(R, stereoLR_rt);
  //printf("posestBinoc(): analytic relative motion: %g %g %g %g %g %g\n", stereoLR_rt[0], stereoLR_rt[1], stereoLR_rt[2], stereoLR_rt[3], stereoLR_rt[4], stereoLR_rt[5]);

  /* monocular pose estimation */
  /* left */
  noutL=(nmatchesL>=nmatchesR)? nmatchesL : nmatchesR; // max(nmatchesL, nmatchesR)
  outidx=(int *)malloc((noutL+1)*sizeof(int)); // +1 for the sentinel below
  if(!outidx){
    fprintf(stderr, "Error: not enough memory for 'outidx' in posestBinoc()\n");
    exit(1);
  }

  //ret=posest(pts2DL, pts3DL, nmatchesL, inlPcent, KL, rtLs, NUM_RTPARAMS, NLrefine, outidx, &noutL, verbose);
  ret=posestRT(pts2DL, pts3DL, nmatchesL, inlPcent, KL, rtLs, NLrefine, outidx, &noutL, verbose);
  if(ret!=POSEST_OK) goto cleanup;

  if(verbose){
    printf("posestBinoc(): estimated motion from left frame ([rv t]) [%d outliers, %.2lf%%]\n", noutL, (double)(100.0*noutL)/nmatchesL);
    printf("\t%g %g %g %g %g %g\n", rtLs[0], rtLs[1], rtLs[2], rtLs[3], rtLs[4], rtLs[5]);
  }

  /* expose left outliers */
  if(idxOutliersLR!=NULL)
    memcpy(idxOutliersLR, outidx, noutL*sizeof(int));

  /* retrieve inlying points for binocular pose refinement. For the 
   * left image, these come from the pose estimation above. For the
   * right one, either pose estimation is employed again or the
   * reprojection error of supplied points & camera matrix is examined 
   */
  inliersidxL=(int *)malloc(nmatchesL*sizeof(int));
  if(!inliersidxL){
    fprintf(stderr, "Error: not enough memory for 'inliersidxL' in posestBinoc()\n");
    exit(1);
  }
  inliersidxR=(int *)malloc(nmatchesR*sizeof(int));
  if(!inliersidxR){
    fprintf(stderr, "Error: not enough memory for 'inliersidxR' in posestBinoc()\n");
    exit(1);
  }

  /* note: following fragment is based on the fact that the indices of outliers is sorted in ascending order */
  outidx[noutL]=nmatchesL; // sentinel
  for(i=j=k=0; i<nmatchesL; ++i)
    if(i<outidx[k]) inliersidxL[j++]=i;
    else ++k;
  ninlL=j;
  *nbOutliersLR=noutL;

  /******************/
#if 0
  {
  double Paux[NUM_PPARAMS];

  sam_PfromKrt(KL, rtLs, rtLs+3, Paux);
  for(i=j=0; i<nmatchesL; ++i){
    double x, y, Z, *M;

    /* project point with Paux */
    M=pts3DL[i];
    x=Paux[0]*M[0] + Paux[1]*M[1] + Paux[2] *M[2] + Paux[3];
    y=Paux[4]*M[0] + Paux[5]*M[1] + Paux[6] *M[2] + Paux[7];
    Z=Paux[8]*M[0] + Paux[9]*M[1] + Paux[10]*M[2] + Paux[11];
    x/=Z; y/=Z;
    printf("LLLL %d:  %g %g    %g %g\n", i+2, x, y, pts2DL[i][0], pts2DL[i][1]);

    x-=pts2DL[i][0]; y-=pts2DL[i][1];
    if(x*x + y*y<=maxreprerrR_sq) inliersidxL[j++]=i;
  }
  ninlL=j;
  *nbOutliersLR=nmatchesL-ninlL;
  }
#endif
  /******************/

  /* right */
#if 1
  /* determine outliers via mono pose estimation on right frame
   * note that outidx is reused below
   */
  //ret=posest(pts2DR, pts3DR, nmatchesR, inlPcent, KR, rtRs, NUM_RTPARAMS, NLrefine, outidx, &noutR, verbose);
  ret=posestRT(pts2DR, pts3DR, nmatchesR, inlPcent, KR, rtRs, NLrefine, outidx, &noutR, verbose);
  if(ret!=POSEST_OK) goto cleanup;

  if(verbose){
    printf("posestBinoc(): estimated motion from right frame ([rv t]) [%d outliers, %.2lf%%]\n", noutR, (double)(100.0*noutR)/nmatchesR);
    printf("\t%g %g %g %g %g %g\n", rtRs[0], rtRs[1], rtRs[2], rtRs[3], rtRs[4], rtRs[5]);
  }

  outidx[noutR]=nmatchesR; // sentinel
  for(i=j=k=0; i<nmatchesR; ++i)
    if(i<outidx[k]) inliersidxR[j++]=i;
    else ++k;
  ninlR=j;
  *nbOutliersLR+=noutR;

  /* expose right outliers */
  if(idxOutliersLR!=NULL){
    for(i=0; i<noutR; ++i) // ensure that R indices are not mixed up with L ones
      outidx[i]+=nmatchesL;
    memcpy(idxOutliersLR+noutL, outidx, noutR*sizeof(int));
  }
#else
  {
  double Paux[NUM_PPARAMS];

  /* determine outliers using a threshold on reprojection error; faster but less reliable */
  /* r_R=stereo_R*rtL, t_R=stereo_R*t_L + stereo_t */
  sam_composeMotionsvec(rtLs, rtLs+3, stereoLR_rt, stereoLR_rt+3, rtRs, rtRs+3);
  sam_PfromKrt(KR, rtRs, rtRs+3, Paux);
  for(i=j=0; i<nmatchesR; ++i){
    double x, y, Z, *M;

    /* project point with Paux */
    M=pts3DR[i];
    x=Paux[0]*M[0] + Paux[1]*M[1] + Paux[2] *M[2] + Paux[3];
    y=Paux[4]*M[0] + Paux[5]*M[1] + Paux[6] *M[2] + Paux[7];
    Z=Paux[8]*M[0] + Paux[9]*M[1] + Paux[10]*M[2] + Paux[11];
    x/=Z; y/=Z;
    //printf("RRRR %d:  %g %g    %g %g\n", i+2, x, y, pts2DR[i][0], pts2DR[i][1]);

    x-=pts2DR[i][0]; y-=pts2DR[i][1];
    if(x*x + y*y<=maxreprerrR_sq) inliersidxR[j++]=i;
  }
  ninlR=j;
  *nbOutliersLR+=(nmatchesR-ninlR);

  /* note: no right outliers exposed here! */

  if(verbose)
    printf("posestBinoc(): detected %d outliers in right frame [%.2lf%%]\n", (nmatchesR-ninlR), (double)(100.0*(nmatchesR-ninlR))/nmatchesR);
  }
#endif

  /* prepare parameters for joint (i.e., binocular) nonlinear refinement */
  opts[0]=LM_INIT_MU; opts[1]=1E-12; opts[2]=1E-12; opts[3]=1E-15;
  opts[4]=LM_DIFF_DELTA; // relevant only if the finite difference Jacobian version is used 

  n=2*(ninlL+ninlR); // two measurements per point
  if((x=(double *)malloc(n*sizeof(double)))==NULL){
    fprintf(stderr, "Error: not enough memory for 'x' in posestBinoc()\n");
    exit(1);
  }

  if(estScale){
    m=NUM_RTPARAMS+1;
    rtLs[NUM_RTPARAMS]=rtRs[NUM_RTPARAMS]=1.0; // initial estimate of multiplicative correction to scale factor
    err=ptsProjRTBinocScale;
    jacerr=ptsProjRTBinocScaleJac;
  }
  else{
    m=NUM_RTPARAMS;
    rtLs[NUM_RTPARAMS]=rtRs[NUM_RTPARAMS]=1.0; // fixed scale factor correction
    err=ptsProjRTBinoc;
    jacerr=ptsProjRTBinocJac;
  }

  /* refinement using L + R inliers */
  data.KL=KL; data.KR=KR;
  data.pts2DL=pts2DL; data.pts3DL=pts3DL;
  data.pts2DR=pts2DR; data.pts3DR=pts3DR;
  data.stereo_rt=stereoLR_rt;
  data.inliersidxL=inliersidxL; data.ninlL=ninlL;
  data.inliersidxR=inliersidxR; data.ninlR=ninlR;

  for(i=0; i<ninlL; ++i){
    j=i<<1; // 2*i
    x[j]  =pts2DL[inliersidxL[i]][0];
    x[j+1]=pts2DL[inliersidxL[i]][1];
  }
  for(i=0; i<ninlR; ++i){
    j=(i+ninlL)<<1; // 2*(i+ninlL)
    x[j]  =pts2DR[inliersidxR[i]][0];
    x[j+1]=pts2DR[inliersidxR[i]][1];
  }

#if USE_ROBUST_LM==0
  retLR=dlevmar_der(err, jacerr, rtLs, x, m, n, 1000, opts, infoLR, NULL, NULL, (void *)&data); // with analytic Jacobian
  //retLR=dlevmar_dif(err, rtLs, x, m, n, 1000, opts, infoLR, NULL, NULL, (void *)&data); // no Jacobian
#else
  { double rp[2];

  /* convex cost function first, then non-convex */
  rp[0]=LM_FAIR; rp[1]=0.8; // Fair
  retLR=dlevmar_rob_der(err, jacerr, rtLs, x, m, n, rp, 1000, opts, infoLR, NULL, NULL, (void *)&data);
  //rp[0]=LM_TUKEY; rp[1]=0.20; // Tukey
  rp[0]=LM_GEMANMCCLURE; rp[1]=0.25; // Geman-McClure
  retLR=dlevmar_rob_der(err, jacerr, rtLs, x, m, n, rp, 200, opts, infoLR, NULL, NULL, (void *)&data);
  }
#endif /* USE_ROBUST_LM */
  rtLs[NUM_RTPARAMS]*=inscale;

  if(verbose){
    fprintf(stdout, "\nBinocular refinement #1 (L-R) using %d measurements, %d variables\n", n, m);
    fprintf(stdout, "posestBinoc(): estimated motion from left & right frames [%d outliers in %d combined matches, %.2lf%%]\n",
        (nmatchesL-ninlL+nmatchesR-ninlR), nmatchesL+nmatchesR, (double)(100.0*(nmatchesL-ninlL+nmatchesR-ninlR))/(nmatchesL+nmatchesR));
    fprintf(stdout, "LM returned %d in %g iter, reason %g, error %g [initial %g], %d/%d func/fjac evals\n",
                    retLR, infoLR[5], infoLR[6], infoLR[1]/(ninlL+ninlR), infoLR[0]/(ninlL+ninlR), (int)infoLR[7], (int)infoLR[8]);
    if(estScale){
      printf("Refined L-R motion ([rv t  scale])\n");
      printf("\t%g %g %g %g %g %g  %.6lf\n", rtLs[0], rtLs[1], rtLs[2], rtLs[3], rtLs[4], rtLs[5], rtLs[6]);
    }
    else{
      printf("Refined L-R motion ([rv t])\n");
      printf("\t%g %g %g %g %g %g\n", rtLs[0], rtLs[1], rtLs[2], rtLs[3], rtLs[4], rtLs[5]);
    }
  }

  if(retLR!=LM_ERROR)
    retLR=POSEST_OK;
  else{
    infoLR[1]=10.0*infoLR[0]; // L-R failed, make sure it won't be selected below
    retLR=POSEST_ERR;
  }

  /* refinement using R + L inliers, i.e. reversing the roles of images */
  /* stereoRL_rt: stereoLR_r^T, -stereoLR_r^T * stereoLR_t */
  stereoRL_rt[0]=-stereoLR_rt[0];
  stereoRL_rt[1]=-stereoLR_rt[1];
  stereoRL_rt[2]=-stereoLR_rt[2];
  sam_vec2rotmat(stereoRL_rt, R); // R <-- stereoLR_r^T
  stereoRL_rt[3]=-R[0]*stereoLR_rt[3] - R[1]*stereoLR_rt[4] - R[2]*stereoLR_rt[5];
  stereoRL_rt[4]=-R[3]*stereoLR_rt[3] - R[4]*stereoLR_rt[4] - R[5]*stereoLR_rt[5];
  stereoRL_rt[5]=-R[6]*stereoLR_rt[3] - R[7]*stereoLR_rt[4] - R[8]*stereoLR_rt[5];

  data.KL=KR; data.KR=KL;
  data.pts2DL=pts2DR; data.pts3DL=pts3DR;
  data.pts2DR=pts2DL; data.pts3DR=pts3DL;
  data.stereo_rt=stereoRL_rt;
  data.inliersidxL=inliersidxR; data.ninlL=ninlR;
  data.inliersidxR=inliersidxL; data.ninlR=ninlL;

  for(i=0; i<ninlR; ++i){
    j=i<<1; // 2*i
    x[j]  =pts2DR[inliersidxR[i]][0];
    x[j+1]=pts2DR[inliersidxR[i]][1];
  }
  for(i=0; i<ninlL; ++i){
    j=(i+ninlR)<<1; // 2*(i+ninlR)
    x[j]  =pts2DL[inliersidxL[i]][0];
    x[j+1]=pts2DL[inliersidxL[i]][1];
  }

#if USE_ROBUST_LM==0
  ret=dlevmar_der(err, jacerr, rtRs, x, m, n, 1000, opts, infoRL, NULL, NULL, (void *)&data); // with analytic Jacobian
  //ret=dlevmar_dif(err, rtLs, x, m, n, 1000, opts, infoRL, NULL, NULL, (void *)&data); // no Jacobian
#else
  { double rp[2];

  /* convex cost function first, then non-convex */
  rp[0]=LM_FAIR; rp[1]=0.8; // Fair
  ret=dlevmar_rob_der(err, jacerr, rtRs, x, m, n, rp, 1000, opts, infoRL, NULL, NULL, (void *)&data);
  //rp[0]=LM_TUKEY; rp[1]=0.20; // Tukey
  rp[0]=LM_GEMANMCCLURE; rp[1]=0.25; // Geman-McClure
  ret=dlevmar_rob_der(err, jacerr, rtRs, x, m, n, rp, 200, opts, infoRL, NULL, NULL, (void *)&data);
  }
#endif /* USE_ROBUST_LM */
  rtRs[NUM_RTPARAMS]*=inscale;

  if(verbose){
    fprintf(stdout, "\nBinocular refinement #2 (R-L) using %d measurements, %d variables\n", n, m);
    fprintf(stdout, "posestBinoc(): estimated motion from left & right frames [%d outliers in %d combined matches, %.2lf%%]\n",
        (nmatchesL-ninlL+nmatchesR-ninlR), nmatchesL+nmatchesR, (double)(100.0*(nmatchesL-ninlL+nmatchesR-ninlR))/(nmatchesL+nmatchesR));
    fprintf(stdout, "LM returned %d in %g iter, reason %g, error %g [initial %g], %d/%d func/fjac evals\n",
                    ret, infoRL[5], infoRL[6], infoRL[1]/(ninlL+ninlR), infoRL[0]/(ninlL+ninlR), (int)infoRL[7], (int)infoRL[8]);
    if(estScale){
      printf("Refined R-L motion ([rv t  scale])\n");
      printf("\t%g %g %g %g %g %g  %.6lf\n", rtRs[0], rtRs[1], rtRs[2], rtRs[3], rtRs[4], rtRs[5], rtRs[6]);
    }
    else{
      printf("Refined R-L motion ([rv t])\n");
      printf("\t%g %g %g %g %g %g\n", rtRs[0], rtRs[1], rtRs[2], rtRs[3], rtRs[4], rtRs[5]);
    }
  }

  if(ret!=LM_ERROR){
    if(infoRL[1]<infoLR[1]){ // R-L solution better than L-R, use it
      /* convert the computed motion to the coordinate system of the left camera */
      /* r_L=stereoRL_r*rtR, t_L=stereoRL_r*t_R + stereoRL_t */
      sam_composeMotionsvec(rtRs, rtRs+3, stereoRL_rt, stereoRL_rt+3, rtLs, rtLs+3);
      //printf("RtoL: %g %g %g %g %g %g\n", rtLs[0], rtLs[1], rtLs[2], rtLs[3], rtLs[4], rtLs[5]);
      rtLs[NUM_RTPARAMS]=rtRs[NUM_RTPARAMS]; // copy scale as is

      ret=(ret!=LM_ERROR)? POSEST_OK : POSEST_ERR;
    }
    else
      ret=POSEST_OK; // retain L-R solution already in rtLs
  }
  else
    ret=retLR;

#if 0 // MLSL on the joint minimization?
{
  double scl[NUM_RTPARAMS+1]={1.0, 1.0, 1.0, 500.0, 500.0, 1500.0, 1.0};
  double lb[NUM_RTPARAMS+1], ub[NUM_RTPARAMS+1], minL2sq;
  
  /* refinement using L + R inliers */
  data.KL=KL; data.KR=KR;
  data.pts2DL=pts2DL; data.pts3DL=pts3DL;
  data.pts2DR=pts2DR; data.pts3DR=pts3DR;
  data.stereo_rt=stereoLR_rt;
  data.inliersidxL=inliersidxL; data.ninlL=ninlL;
  data.inliersidxR=inliersidxR; data.ninlR=ninlR;

  for(i=0; i<ninlL; ++i){
    j=i<<1; // 2*i
    x[j]  =pts2DL[inliersidxL[i]][0];
    x[j+1]=pts2DL[inliersidxL[i]][1];
  }
  for(i=0; i<ninlR; ++i){
    j=(i+ninlL)<<1; // 2*(i+ninlL)
    x[j]  =pts2DR[inliersidxR[i]][0];
    x[j+1]=pts2DR[inliersidxR[i]][1];
  }

  lb[0]=-1.5+rtLs[0];    ub[0]=1.5+rtLs[0];
  lb[1]=-1.5+rtLs[1];    ub[1]=1.5+rtLs[1];
  lb[2]=-1.5+rtLs[2];    ub[2]=1.5+rtLs[2];
  lb[3]=-300.+rtLs[3];   ub[3]=300.+rtLs[3];
  lb[4]=-300.+rtLs[4];   ub[4]=300.+rtLs[4];
  lb[5]=-700.+rtLs[5];   ub[5]=700.+rtLs[5];
  lb[6]=-0.2+rtLs[6];    ub[6]=0.2+rtLs[6];

# if 0
  printf("L binoc bounds: %g %g %g %g %g %g\n", lb[0], lb[1], lb[2], lb[3], lb[4], lb[5]);
  printf("U binoc bounds: %g %g %g %g %g %g\n", ub[0], ub[1], ub[2], ub[3], ub[4], ub[5]);
#endif

  mlsl_dlevmar_der(err, jacerr, rtLs, x, m, n, lb, ub, scl, 500, opts, infoLR, NULL, NULL, (void *)&data, &minL2sq, 5, 1, verbose);
}
#endif

  free(x);

cleanup:
  if(inliersidxL) free(inliersidxL);
  if(inliersidxR) free(inliersidxR);
  free(outidx);

 #if 0
  /* the following fragment converts the computed motion to the coordinate system of the RIGHT camera */
  /* r_R=stereoLR_R*rtL, t_R=stereoLR_R*t_L + stereoLR_t */
  sam_composeMotionsvec(rtLs, rtLs+3, stereoLR_rt, stereoLR_rt+3, rtRs, rtRs+3);
  printf("LtoR: %g %g %g %g %g %g\n", rtRs[0], rtRs[1], rtRs[2], rtRs[3], rtRs[4], rtRs[5]);
  memcpy(rtLs, rtRs, NUM_RTPARAMS*sizeof(double)); // scale left intact
#endif

  if(verbose){
    if(ret==POSEST_OK){
      if(estScale){
        printf("\nBinocularly refined motion ([rv t  scale])\n");
        printf("\t%g %g %g %g %g %g  %.6lf\n\n", rtLs[0], rtLs[1], rtLs[2], rtLs[3], rtLs[4], rtLs[5], rtLs[6]);
      }
      else{
        printf("\nBinocularly refined motion ([rv t])\n");
        printf("\t%g %g %g %g %g %g\n\n", rtLs[0], rtLs[1], rtLs[2], rtLs[3], rtLs[4], rtLs[5]);
      }
    }
    else
      printf("\nBinocular refinement failed!\n");
  }

  if(inscale!=1.0){ // undo scaling
    for(i=0; i<nmatchesL; ++i){
      pts3DL[i][0]/=inscale;
      pts3DL[i][1]/=inscale;
      pts3DL[i][2]/=inscale;
    }
    for(i=0; i<nmatchesR; ++i){
      pts3DR[i][0]/=inscale;
      pts3DR[i][1]/=inscale;
      pts3DR[i][2]/=inscale;
    }
  }

  return ret;
}

/* similar to posest_RMS_RMedS() for the binocular case; first two lines of args are as in posestBinoc(),
 * rtLs is the left camera pose & scale as estimated by posestBinoc()
 */
void posestBinoc_RMS_RMedS(double (*pts2DL)[2], double (*pts3DL)[3], int nmatchesL, double PextL[NUM_PPARAMS],
                           double (*pts2DR)[2], double (*pts3DR)[3], int nmatchesR, double PextR[NUM_PPARAMS],
                           double rtLs[NUM_RTPARAMS+1],
                           double *rms, double *rmeds)
{
register int i;
double *errors, sum, q[2], s, dist;
double X, Y, Z;
int totmatches;
double RextL[9], textL[3], KL[9], RextR[9], textR[3], KR[9], R[9], stereo_rt[NUM_RTPARAMS], rtR[NUM_RTPARAMS];
double scl, P[NUM_PPARAMS];

  totmatches=nmatchesL+nmatchesR;
  if((errors=(double *)malloc(totmatches*sizeof(double)))==NULL){
     fprintf(stderr, "Memory allocation request failed in posestBinoc_RMS_RMedS() %d\n", totmatches);
     exit(1);
  }

  /* extract stereo R,t from PextL, PextR */
  sam_KRtfromP(PextL, KL, RextL, textL);
  sam_KRtfromP(PextR, KR, RextR, textR);
  sam_relMotion(RextL, textL, RextR, textR, R, stereo_rt+3); // R, t s.t. RextR=R*RextL, textR=R*textL+t
  sam_rotmat2vec(R, stereo_rt);

  scl=rtLs[NUM_RTPARAMS];

  /* left */
  posest_PfromKRt(P, KL, rtLs); // P = KL [RL tL]
  for(i=0, sum=0.0; i<nmatchesL; ++i){
    /* project pts3DL[i] using P */
    X=scl*pts3DL[i][0]; Y=scl*pts3DL[i][1]; Z=scl*pts3DL[i][2];

      q[0]=P[0]*X + P[1]*Y +  P[2]*Z + P[3];
      q[1]=P[4]*X + P[5]*Y +  P[6]*Z + P[7];
    s=1.0/(P[8]*X + P[9]*Y + P[10]*Z + P[11]);
    q[0]*=s; q[1]*=s;

    q[0]-=pts2DL[i][0];
    q[1]-=pts2DL[i][1];

    dist=SQR(q[0]) + SQR(q[1]);
    sum+=errors[i]=dist;
  }

  /* right */
  /* r_R=stereo_R*rtL, t_R=stereo_R*t_L + stereo_t */
  sam_composeMotionsvec(rtLs, rtLs+3, stereo_rt, stereo_rt+3, rtR, rtR+3);
  posest_PfromKRt(P, KR, rtR); // P = KR [RR tR]
  for(i=0; i<nmatchesR; ++i){
    /* project pts3DR[i] using P */
    X=scl*pts3DR[i][0]; Y=scl*pts3DR[i][1]; Z=scl*pts3DR[i][2];

      q[0]=P[0]*X + P[1]*Y +  P[2]*Z + P[3];
      q[1]=P[4]*X + P[5]*Y +  P[6]*Z + P[7];
    s=1.0/(P[8]*X + P[9]*Y + P[10]*Z + P[11]);
    q[0]*=s; q[1]*=s;

    q[0]-=pts2DR[i][0];
    q[1]-=pts2DR[i][1];

    dist=SQR(q[0]) + SQR(q[1]);
    sum+=errors[nmatchesL+i]=dist;
  }

  *rms=sqrt(sum/(double)(totmatches));
  *rmeds=sqrt(_MEDIAN_(errors, totmatches));
//*rmeds=sqrt(lqs_kth_smallest(errors, totmatches, (totmatches>>2))); // 25%

  free(errors);
}

/* similar to posest_quartiles() for the binocular case; first two lines of args are as in posestBinoc(),
 * rtLs is the left camera pose & scale as estimated by posestBinoc()
 */
void posestBinoc_quartiles(double (*pts2DL)[2], double (*pts3DL)[3], int nmatchesL, double PextL[NUM_PPARAMS],
                           double (*pts2DR)[2], double (*pts3DR)[3], int nmatchesR, double PextR[NUM_PPARAMS],
                           double rtLs[NUM_RTPARAMS+1],
                           double *Q1, double *Q2, double *Q3)
{
register int i;
double *errors, q[2], s, dist;
double X, Y, Z;
int totmatches;
double RextL[9], textL[3], KL[9], RextR[9], textR[3], KR[9], R[9], stereo_rt[NUM_RTPARAMS], rtR[NUM_RTPARAMS];
double scl, P[NUM_PPARAMS];

  totmatches=nmatchesL+nmatchesR;
  if((errors=(double *)malloc(totmatches*sizeof(double)))==NULL){
     fprintf(stderr, "Memory allocation request failed in posestBinoc_quartiles() %d\n", totmatches);
     exit(1);
  }

  /* extract stereo R,t from PextL, PextR */
  sam_KRtfromP(PextL, KL, RextL, textL);
  sam_KRtfromP(PextR, KR, RextR, textR);
  sam_relMotion(RextL, textL, RextR, textR, R, stereo_rt+3); // R, t s.t. RextR=R*RextL, textR=R*textL+t
  sam_rotmat2vec(R, stereo_rt);

  scl=rtLs[NUM_RTPARAMS];

  /* left */
  posest_PfromKRt(P, KL, rtLs); // P = KL [RL tL]
  for(i=0; i<nmatchesL; ++i){
    /* project pts3DL[i] using P */
    X=scl*pts3DL[i][0]; Y=scl*pts3DL[i][1]; Z=scl*pts3DL[i][2];

      q[0]=P[0]*X + P[1]*Y +  P[2]*Z + P[3];
      q[1]=P[4]*X + P[5]*Y +  P[6]*Z + P[7];
    s=1.0/(P[8]*X + P[9]*Y + P[10]*Z + P[11]);
    q[0]*=s; q[1]*=s;

    q[0]-=pts2DL[i][0];
    q[1]-=pts2DL[i][1];

    dist=SQR(q[0]) + SQR(q[1]);
    errors[i]=dist;
  }

  /* right */
  /* r_R=stereo_R*rtL, t_R=stereo_R*t_L + stereo_t */
  sam_composeMotionsvec(rtLs, rtLs+3, stereo_rt, stereo_rt+3, rtR, rtR+3);
  posest_PfromKRt(P, KR, rtR); // P = KR [RR tR]
  for(i=0; i<nmatchesR; ++i){
    /* project pts3DR[i] using P */
    X=scl*pts3DR[i][0]; Y=scl*pts3DR[i][1]; Z=scl*pts3DR[i][2];

      q[0]=P[0]*X + P[1]*Y +  P[2]*Z + P[3];
      q[1]=P[4]*X + P[5]*Y +  P[6]*Z + P[7];
    s=1.0/(P[8]*X + P[9]*Y + P[10]*Z + P[11]);
    q[0]*=s; q[1]*=s;

    q[0]-=pts2DR[i][0];
    q[1]-=pts2DR[i][1];

    dist=SQR(q[0]) + SQR(q[1]);
    errors[nmatchesL+i]=dist;
  }

  if(Q1) *Q1=sqrt(lqs_kth_smallest(errors, totmatches, (totmatches>>2))); // 25%
  if(Q2) *Q2=sqrt(lqs_kth_smallest(errors, totmatches, (totmatches>>1))); // 50%
  if(Q3) *Q3=sqrt(lqs_kth_smallest(errors, totmatches, totmatches-(totmatches>>2))); // 75%

  free(errors);
}


/* similar to posest_percentile() for the binocular case; first two lines of args are as in posestBinoc(),
 * rtLs is the left camera pose & scale as estimated by posestBinoc()
 */
double posestBinoc_percentile(double (*pts2DL)[2], double (*pts3DL)[3], int nmatchesL, double PextL[NUM_PPARAMS],
                           double (*pts2DR)[2], double (*pts3DR)[3], int nmatchesR, double PextR[NUM_PPARAMS],
                           double rtLs[NUM_RTPARAMS+1],
                           double pct)
{
register int i;
double *errors, q[2], s, dist;
double X, Y, Z;
int totmatches;
double RextL[9], textL[3], KL[9], RextR[9], textR[3], KR[9], R[9], stereo_rt[NUM_RTPARAMS], rtR[NUM_RTPARAMS];
double scl, P[NUM_PPARAMS];

  totmatches=nmatchesL+nmatchesR;
  if((errors=(double *)malloc(totmatches*sizeof(double)))==NULL){
     fprintf(stderr, "Memory allocation request failed in posestBinoc_percentile() %d\n", totmatches);
     exit(1);
  }

  /* extract stereo R,t from PextL, PextR */
  sam_KRtfromP(PextL, KL, RextL, textL);
  sam_KRtfromP(PextR, KR, RextR, textR);
  sam_relMotion(RextL, textL, RextR, textR, R, stereo_rt+3); // R, t s.t. RextR=R*RextL, textR=R*textL+t
  sam_rotmat2vec(R, stereo_rt);

  scl=rtLs[NUM_RTPARAMS];

  /* left */
  posest_PfromKRt(P, KL, rtLs); // P = KL [RL tL]
  for(i=0; i<nmatchesL; ++i){
    /* project pts3DL[i] using P */
    X=scl*pts3DL[i][0]; Y=scl*pts3DL[i][1]; Z=scl*pts3DL[i][2];

      q[0]=P[0]*X + P[1]*Y +  P[2]*Z + P[3];
      q[1]=P[4]*X + P[5]*Y +  P[6]*Z + P[7];
    s=1.0/(P[8]*X + P[9]*Y + P[10]*Z + P[11]);
    q[0]*=s; q[1]*=s;

    q[0]-=pts2DL[i][0];
    q[1]-=pts2DL[i][1];

    dist=SQR(q[0]) + SQR(q[1]);
    errors[i]=dist;
  }

  /* right */
  /* r_R=stereo_R*rtL, t_R=stereo_R*t_L + stereo_t */
  sam_composeMotionsvec(rtLs, rtLs+3, stereo_rt, stereo_rt+3, rtR, rtR+3);
  posest_PfromKRt(P, KR, rtR); // P = KR [RR tR]
  for(i=0; i<nmatchesR; ++i){
    /* project pts3DR[i] using P */
    X=scl*pts3DR[i][0]; Y=scl*pts3DR[i][1]; Z=scl*pts3DR[i][2];

      q[0]=P[0]*X + P[1]*Y +  P[2]*Z + P[3];
      q[1]=P[4]*X + P[5]*Y +  P[6]*Z + P[7];
    s=1.0/(P[8]*X + P[9]*Y + P[10]*Z + P[11]);
    q[0]*=s; q[1]*=s;

    q[0]-=pts2DR[i][0];
    q[1]-=pts2DR[i][1];

    dist=SQR(q[0]) + SQR(q[1]);
    errors[nmatchesL+i]=dist;
  }

  X=sqrt(lqs_kth_smallest(errors, totmatches, (int)(totmatches*pct))); // pct%

  free(errors);

  return X;
}
